[{"title":"Linux内核分析五","date":"2017-03-26T02:24:33.000Z","path":"2017/03/26/Linux内核分析五/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、实践1.使用gdb跟踪分析4号系统调用内核函数：sys_write在test.c中增加我编写的两个函数：MyPrint()和MyPrintAsm(),这两个函数的作用是输出一条msg，代码如下：123456789101112131415161718192021int MyPrint() &#123; char* msg = \"Hello Linux\"; printf(\"%s\", msg); return 0; &#125;int MyPrintAsm() &#123; char* msg = \"Hello Linux\"; int len = 11; int result = 0; __asm__ __volatile__(\"movl %2, %%edx;\\n\\r\" \"movl %1, %%ecx;\\n\\r\" \"movl $1, %%ebx;\\n\\r\" \"movl $4, %%eax;\\n\\r\" \"int $0x80\" :\"=m\"(result) :\"m\"(msg),\"r\"(len) :\"%eax\"); return 0; &#125; 在main函数中增加两个函数的MenuConfig命令项：12MenuConfig(\"hello\",\"print hello info\",MyPrint);MenuConfig(\"hello-asm\",\"print hello info(asm)\",MyPrintAsm); 将修改后的menu放入LinuxKernel目录下，执行menu下的makefile编译运行menuOS，在MenuOS中输入help，可以查看当前所有的系统调用，分别执行hello、hello-asm进行系统调用，结果如下图所示： 二、调试内核1.使用gdb跟踪调试内核 qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -Sgdb（gdb）file linux-3.18.6/vmlinux（gdb）target remote:1234b sys_time：在系统调用time的位置设置断点c：在MenuOs里使用time，停在断点处s 单步调试—一步一步执行（PS：无法执行time_asm中的int 0X80部分） 调试如下所示：可以看到，在输入hello指令后，系统调用了sys_write函数来进行输出。 三、分析系统调用在内核代码中的处理过程1.系统调用在内核代码中的工作机制和初始化 main.c中start_kernel函数：trap_init()set_system_trap_gate(SYSCALL_VECTOR,&amp;system_call)SYSCALL_VECTOR：系统调用的中断向量&amp;system_call：汇编代码入口一执行int 0x80，系统直接跳转到system_call。 2.系统调用——一个特殊的中断 SAVE_ALL：保存现场call *sys_call_table(,%eax,4)调用了系统调度处理函数，eax存的是系统调用号，是实际的系统调度程序。sys_call_table：系统调用分派表syscall_after_all：保存返回值若有sys_exit_work，则进入sys_exit_work:会有一个进程调度时机。work_pending -&gt; work_notifysig，用来处理信号可能call schedule：进程调度代码可能跳转到restore_all，恢复现场。若无sys_exit_work，就执行restore_all恢复，返回用户态。INTERRUPT_RETURN &lt;=&gt; iret，结束。 在系统调用返回之前，可能发生进程调度，进程调度里就会出现进程上下文的切换。- 进程间通信可能有信号需要处理。- 可以将内核视为一系列中断指令的集合。 四、总结：从系统调用处理过程到一般的中断处理过程系统调用就是特殊的一种中断1.保存现场在系统调用时，我们需要SAVE_ALL，用于保存系统调用时的上下文。同样，中断处理的第一步应该也要保存中断程序现场。目的：在中断处理完之后，可以返回到原来被中断的地方，在原有的运行环境下继续正确的执行下去。2.确定中断信息在系统调用时，我们需要将系统调用号通过eax传入，通过sys_call_table查询到调用的系统调用。同样，中断处理时系统也需要有一个中断号，通过检索中断向量表，了解中断的类型和设备。3.处理中断跳转到相应的中断处理程序后，对中断进行处理。4.返回系统调用时最后要restore_all恢复系统调用时的现场，并用iret返回用户态。同样，执行完中断处理程序，内核也要执行特定指令序列，恢复中断时现场，并使得进程回到用户态。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析四","date":"2017-03-19T11:24:31.000Z","path":"2017/03/19/Linux内核分析四/","text":"一、预备知识（1）用户栈与内核栈内核栈：存在于内核空间，当进程在内核栈里运行时，CPU栈顶指针寄存器里面的内容是内核栈空间地址，使用内核栈。用户栈：存在于用户空间，当进程在用户栈里运行时，CPU栈顶指针寄存器里面的内容是用户栈空间地址，使用用户栈。（2）用户态与内核态用户态：用户在非特权模式下，访问会资源会受到限制。内核栈：用户在特权模式下，可随意访问资源为什么要区分用户态与内核态？因为在操作系统中有很多很重要的代码要保证安全性，不可被任意修改，区别用户态和内核态可访问的空间，保证了系统的安全，防止因不当操作而造成的系统崩溃。在Linux中有0和3两种运行级别：0表示内核态，3表示用户态 （3）利用地址空间区别内核态和用户态只有内核态可以访问0xc0000000以上的地址空间，0x00000000到0xbfffffff在两种状态下都可以访问（4）内核态与用户态的切换当进程因为硬件中断或者系统调用，而从用户态转变为内核态时，进程所使用的堆栈要从用户栈变为内核栈，此时进程进入内核态后，首先，在内核态上保存用户态堆栈上的地址，设置堆栈指针寄存器的内容为当前进程的内核栈地址，这样就完成了用户栈向内核栈的切换。当进程从内核态恢复到用户态时，将内核态保存的用户态的堆栈地址恢复到栈指针寄存器，这样就完成了内核态向用户态的切换。（5）系统调用1.系统调用与API（应用程序编程接口）区别API只是一个函数定义，而系统调用通过软中断向内核发出一个明确的请求。不是每个API都对应一个特定的系统调用。首先，API可能直接提供用户态的服务(比如一些数学函数)，其次，一个单独的API可能调用几个系统调用，不同的API可能调用了同一个系统调用。2.系统调用的优点系统调用为用户提供了调用与硬件设备等进行交互的接口，可以将用户从底层的硬件编程中解放出来，提高系统的安全性，是用户程序具有更好的可移植性。3.系统调用时执行的操作1）在进程的内核态堆栈中保存大多数寄存器的内容(即保存恢复进程到用户态执行所需要的上下文)2）根据用户态传递的系统调用号，确定系统调用的服务例程3）调用名为系统调用服务例程的相应的C函数来处理系统调用4）从系统调用返回 二、实验过程1.首先看下示例的time程序，代码如下所示：1234567891011#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123; time_t tt; struct tm *t; tt = time(NULL); t = localtime(&amp;tt); printf(\"time:%d/%d/%d ,%d:%d:%d\\n\",t-&gt;tm_year+1900,t-&gt;tm_mon,t-&gt;tm_mday,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec); return 0;&#125; 用gcc time.c -o time -m32编译后，输出结果如下所示： 2.利用内嵌汇编代码的方式来实现上面的程序，代码如下所示： 程序执行结果如下： 3.实现一个简单的printf的程序，输出Hello，Linux,代码如下：12345678#include \"stdio.h\" #include \"string.h\" int main() &#123; char* msg = \"Hello Linux\"; printf(\"%s\", msg); return 0; &#125; 编译运行结果如下： 4.再用内嵌汇编代码的方式来实现printf，系统调用号为4，代码如下所示:1234567891011121314151617#include \"stdio.h\" #include \"string.h\" int main() &#123; char* msg = \"Hello Linux\"; int len = 11; int result = 0; __asm__ __volatile__(\"movl %2, %%edx;\\n\\r\" \"movl %1, %%ecx;\\n\\r\" \"movl $1, %%ebx;\\n\\r\"\\ \"movl $4, %%eax;\\n\\r\" \"int $0x80\" :\"=m\"(result) :\"m\"(msg),\"r\"(len) :\"%eax\"); return 0; &#125; 编译运行结果如下： 三、总结Linux 下的系统调用是通过中断（int 0x80）来实现的。在执行 int 80 指令时，寄存器 eax 中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi 中，当系统调用完成之后，返回值可以在寄存器 eax 中获得。所有的系统调用功能号都可以在文件 /usr/include/bits/syscall.h 中找到，为了便于使用，它们是用 SYS_ 这样的宏来定义的，如 SYS_write、SYS_exit 等。例如，经常用到的 write 函数是如下定义的： ssize_t write(int fd, const void *buf, size_t count); 该函数的功能最终是通过 SYS_write 这一系统调用来实现的。根据上面的约定，参数 fb、buf 和 count 分别存在寄存器 ebx、ecx 和 edx 中，而系统调用号 SYS_write 则放在寄存器 eax 中，当 int 0x80 指令执行完毕后，返回值可以从寄存器 eax 中获得。或许你已经发现，在进行系统调用时至多只有 5 个寄存器能够用来保存参数，难道所有系统调用的参数个数都不超过 5 吗？当然不是，例如 mmap 函数就有 6 个参数，这些参数最后都需要传递给系统调用 SYS_mmap： void mmap(void start, size_t length, int prot , int flags, int fd, off_t offset); 当一个系统调用所需的参数个数大于 5 时，执行int 0x80 指令时仍需将系统调用功能号保存在寄存器 eax 中，所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针。系统调用完成之后，返回值仍将保存在寄存器 eax 中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此完全可以像普通的函数调用一样使用栈(stack)来传递系统调用所需的参数。但要注意一点，Linux 采用的是 C 语言的调用模式，这就意味着所有参数必须以相反的顺序进栈，即最后一个参数先入栈，而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数，在执行int 0x80 指令时还应该将栈指针的当前值复制到寄存器 ebx中。今天的实验可以形象化的将其记忆为：系统调用可以看成三层皮：API函数，system_ call,sys _xxx()系统调用服务例程。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析三——跟踪分析Linux内核的启动过程","date":"2017-03-12T12:18:04.000Z","path":"2017/03/12/Linux内核分析三/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、基础知识（1）Linux内核中常用的目录arch/ 是体系结构相关的代码，其中的/x86 文件夹下的内容是x86体系结构相关代码，是内核分析的重要分析目标。init/ 是内核启动相关的代码，是本文的重点分析对象。/init/main.c 文件是内核启动的起点，是分析内核启动流程的首要分析对象。fs/ 文件系统（file system?）kernel/ 内核相关的代码，一些内核中使用到的结构体、函数等重要对象的定义都在这里面。mm/ 内存管理的相关代码（memory managment?） （2）使用gdb调试工具的基本指令1.gdb 可执行文件名：进入gdb调试2.（gdb）l：相当于list，从第一行开始列出源码3.（gdb）回车：重复上一次指令4.（gdb）break 函数名/行数：在某一行或者某个函数处设置断点5.（gdb）info break:查看断点信息6.在断点内可以使用：r（run运行）,n（next单句执行）,c（contiune继续执行）7.（gdb）bt:查看函数堆栈8.（gdb）finis:退出函数9.（gdb）q:退出gdb （3）Linux内核启动过程Linux系统的启动分为4个部分：引导加载程序（bootloader）,Linux内核，文件系统，应用程序，其中，在Linux内核启动时我们完成了系统的重要初始化，并创建了init进程。 内核启动主要可以分为两个阶段：第一阶段主要是与硬件相关的初始化工作，这次我们讨论的主要是第二部分。 在内核源码的init/main.c中，定义了内核启动的入口函数start_kernel(),在start _kernel()中调用相关处理程序函数， 创建了0号进程（set _task _stack _end _magic(&amp;init _task)）， 设置体系结构的相关环境（setup _arch）, 初始化内存结构（bootmem _init）, 开启mmu， 建立页表（paging _init）, 初始化串口（console _init）， 0号进程是所有进程的父进程，0号进程创建了1号进程init，又创建了其他服务例程。 二、实验执行——通过gdb调试，分析Linux的内核启动过程（1）实验步骤：1.使用实验楼已配置好的环境， cd LinuxKernel/qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img 2.进入gdb调试： qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S其中：-S 是指在初始化cpu之前将cpu冻结-s 是指在-gdb tcp ：：1234，创建一个gdb server 另开一个shell窗口：（gdb）file linux-3.18.6/vmlinux （gdb）target remote:1234（gdb）break start_kernel（gdb）c !在start_kernel处设置断点，执行c调试，冻结的系统开始启动,断点执行到start _kernel,start_kernel()函数是一切的起点，在这个函数被调用之前都是系统的初始化工作（汇编语言），所以对内核的启动分析一般都从这个函数开始；main.c中没有main函数，start_kernel()这个函数就相当于是c程序中的main函数。下面从这个函数开始对内核的启动流程进行分析。首先，是init_task,它其实就是一个task_struct，与用户进程的task_struct一样， task_struct中保存了一个进程的所有基本信息，如进程状态，栈起始地址，进程号pid等；init_task的特殊之处在于它的pid=0,也就是通常所说的0号进程,在创建了0号进程之后，start_kernel()函数继续调用各个系统模块进行各种初始化之类的工作，比如： trap_init()完成中断向量的相关设置调用mm_init()完成内存管理的设置调用sched_init()完成调度模块的初始化 若设置断点在rest_init,这样子就调用了另一个非常重要的函数rest_init()，它的位置在/linux-3.18.6/init/main.c，其代码如下：123456789101112131415161718192021222324252627393static noinline void __init_refok rest_init(void)394&#123;395 int pid;396397 rcu_scheduler_starting();398 /*399 * We need to spawn init first so that it obtains pid 1, however400 * the init task will end up wanting to create kthreads, which, if401 * we schedule it before we create kthreadd, will OOPS.402 */403 kernel_thread(kernel_init, NULL, CLONE_FS);404 numa_default_policy();405 pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);406 rcu_read_lock();407 kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);408 rcu_read_unlock();409 complete(&amp;kthreadd_done);410411 /*412 * The boot idle thread must execute schedule()413 * at least once to get things moving:414 */415 init_idle_bootup_task(current);416 schedule_preempt_disabled();417 /* Call into cpu_idle with preempt disabled */418 cpu_startup_entry(CPUHP_ONLINE);419&#125; rest_init()函数中这行代码： kernel_thread(kernel_init, NULL, CLONE_FS);这个函数的功能是创建一个内核线程,kernel_thread函数中第一个参数是一个函数指针，也就是说内核此时fork出了一个新进程来执行kernel_init函数（低版本内核中这个函数名为init，为了区分init进程所以将其改为了kernel_init）;在kernel_init函数(/linux-3.18.6/init/main.c)正式启动了init进程,也就是1号进程。在kernel _init中，调用了run _init _process ()，默认的init是根目录下的init，如果在根目录下没有，则找/sbin/init,/etc/init,/bin/init,/bin/sh作为1号进程，则kernel init创建了一个1号进程， 执行kernel thread（kernel threaddd,NULL,CLONE FS|CLONE FILES）,创建内核线程管理系统的运行资源，在rest init()尾部，进入了cpu startup entry(…),进入cpu idle,执行cpu idle _ loop(),在cpu idle loop()进行while(1)的循环处理，这就是0号进程。当系统没有进程需要执行时就调度到idle进程 ,start_kernel()启动时rest _init就一直存在，也就是0号进程，0号进程创建了1号进程，还创建了其他的服务线程，这样内核就启动起来了。 三、实验总结本次实验主要分析了在内核启动过程中的第一个函数：start_kernel的执行。startkernel（）是init/main.c第一个启动的函数，主要完成了很多重要的与硬件平台相关和内核相关的初始化，并创建了init进程。 在init的start kernel()中调用了setup_ arch()进行与体系结构相关的第一个初始化， 通过bottom_init()函数根据系统定义的meminfo结构进行内存初始化， 最后paging_init()开启mmu，创建内核页表，映射所有的物理内存和I/O空间， 完成了创建异常向量表和初始化中断处理函数，初始化系统核心进程调度器和时钟中断处理机制，初始化串口控制台（serialconsole）等等， 当所有的相关操作结束后，start kernel（）会调用rest_ init()进行最后初始化，包括创建系统的第一个进程——init进程，init进程首先进行一系列的硬件初始化，然后通过命令行传递过来的参数挂在根文件系统，init进程会执行用户传递过来的参数执行用户指定的命令或者执行/sbin/init,/etc/init,/bin/init,/bin/sh 之一完成初始化工作，cpu_idle会被调用使系统处于闲置状态并等待用户输入。这次实验重点在于linux中启动过程的进程产生于分析，正如孟宁老师所说，“道生一（start_kernel….cpu_idle），一生二（kernel_init和kthreadd），二生三（即前面0、1和2三个进程），三生万物（1号进程是所有用户态进程的祖先，2号进程是所有内核线程的祖先），这些“都符合中国传统文化精神了”，也就不难让人理解了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析二——操作系统如和工作","date":"2017-03-05T12:27:43.000Z","path":"2017/03/05/Linux内核分析二/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、理论知识1.计算机是如何工作的？——总结关键的三点（1）存储计算机模型——计算机系统中最最基础的数据结构（2）函数调用堆栈——高级语言得以运行的基础堆栈完成了计算机的基本功能：函数的参数传递机制和局部变量存取（3）中断：多道程序操作系统的基点 2.堆栈：C语言运行时必须记得调用路径和调用参数空间（1）堆栈的基本功能：函数调用框架、传递参数（32位）、保存返回地址（如eax保存返回值/内存地址）、提供局部变量空间（2）与堆栈相关的寄存器：esp和ebp 与堆栈相关的操作：push（入栈时esp指针会减4）、pop（出栈时esp指针会加4）（3）CS：eip总是指向下一条指令的地址 3.堆栈的工作过程（1）函数堆栈的形成过程函数的堆栈框架由下图展示： （2）函数堆栈框架的形成过程 二、实验内容——通过编一个简单的时间片轮转多道程序内核代码理解操作系统的进程上下文切换等 （1）实验过程、代码以及截图1.实验步骤：在实验楼的虚拟机中打开shell，执行12345678cd LinuxKernel/linux-3.9.4rm -rf mykernel //删除已存在的旧文件patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch //为内核打补丁,新增自己添加的功能make allnoconfigmake //编译过程时间较长//编译成功后执行qemu -kernel arcj/x86/boot/bzImage 2.实验结果如下：可以看到每当i增加100000会执行（printf函数输出my start kernel _ here …）时会触发一次时钟中断，在由时钟中断处理函数输出（&gt;..&gt;&gt;my_timer_handler&lt;&lt;…&lt;）代码实现如下：myinterrupt.c中实现了时钟处理函数 （2）设计一个简单的时间片轮转多道程序这个实验简单的模拟实现了一个操作系统的进程调度首先，创建一个mypcb.h的头文件，该头文件用于声明会用到的结构体以及函数（实验的相关代码可从），代码如下：1234567891011121314151617181920212223//最多任务数量#define MAX_TASK_NUM 4//内核堆栈大小#define KERNEL_STACK_SIZE 1024*8//定义结构体储存信息struct Thread&#123; unsigned int ip;//用于记录eip的值 unsigned int sp;//用于记录esp的值&#125;;//定义进程控制块，用于记录进程的相关信息typedef struct PCB&#123; unsigned int pid;//pid唯一标识 volatile long state; //进程的状态，-1没有运行，0正在运行，&gt;0停止 char stack[KERNEL_STACK_SIZE]; struct Thread thread; unsigned long task_entry;//进行的函数入口 struct PCB *next;//将进程连接起来&#125;tPCB;//调度函数void my_schedule(); 将mymain.c进行修改（主要是修改__init my _start _kernel()函数），完成基本的创建0号线程，创建其他线程并赋予线程信息，主要代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"mypcb.h\"tPCB task[TASK_MAX_NUM];tPCB *my_current_task;//当前任务的指针volatile int my_need_sched = 0; void my_process(void);void __init my_start_kernel(void)&#123; //初始化当前0号进程 int pid = 0; int i; task[pid].state=0; //正在运行的eip task[pid].thread.ip=(unsigned int)my_process task[pid].thread.sp=(unsigned long)&amp;task[pid].stack[KERNEL_STACK_SIZE-1]; task[pid].task_entry = &amp;task[pid].thread.ip; task[pid].next=&amp;task[pid]; //创建其他进程 for(i=1;i&lt;MAX_TASK_NUM;i++) &#123; //复制0号进程的信息 memcpy(&amp;task[i],&amp;task[0],sizeof(tPCB)); task[i].pid = i; task[i].state=-1;//没有运行 task[i].thread.sp=(unsigned long)&amp;task[i].stack[KERNEL_STACK_SIZE-1]; //链接，尾部插入 task[i].next=task[i-1].next; task[i-1].next = task[i]; &#125; //启动0号进程 pid=0; my_current_task=&amp;task[pid]; //内嵌汇编代码，执行保护现场和恢复现场 asm volatile( \"movl %1,%%esp\\n\\t\" //保存thread.sp-----&gt;esp \"pushl %1\\n\\t\"//将thread.sp压栈 \"pushl %0\\n\\t\"//将thread.ip入栈 \"ret\\n\\t\" //将eip弹出 //当前的eip为task[pid].thread.ip=(unsigned int)my_process，所以执行my_process() \"popl %%ebp\\n\\t\"//执行结束，恢复现场 : :\"c\"(task[pid].thread.ip),\"d\"(task[pid].thread.sp) );&#125;void my_process(void)&#123; int i=0; while(1) &#123; i++; if(i%10000000 == 0) &#123; //active schedule //every 10000000 execute printk(KERN_NOTICE\"this is process %d-\\n\",my_current_task-&gt;pid); if(my_need_sched == 1) &#123; my_need_sched = 0; my_schedule(); &#125; printk(KERN_NOTICE\"this is process %d+\\n\",my_current_task-&gt;pid); &#125; &#125;&#125; 在这个地方：0号进程的启动：（0号进程是第一个启动的进程）将esp置为当前进程的esp，然后将esp的值压栈，与ebp形成0号进程的自己的堆栈空间，将0号进程的task[pid].thread.ip也压栈，ret后，此时0号进程开始执行。当0号进程启动时，my current task指向task[0]，此时要执行0号进程的 task entry,task[pid].task entry = &amp;task[pid].thread.ip,当前的eip为task[pid].thread.ip=(unsigned int)my process，所以执行my process(), 在my process中有一个while(1)循环，my need _ sched的初始值是0。接着看my_interrupt.c函数，找到调度何时会发生。 修改my_interrupt.c:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include \"mypcb.h\"extern tPCB task[MAX_TASK_NUM];extern tPCB *my_current_task;extern volatile int my_need_sched;volatile int time_count = 0;//计时器/* * Called by timer interrupt. */void my_timer_handler(void)&#123;#if 1 if(time_count%1000 == 0 &amp;&amp; my_need_sched != 1) &#123; printk(KERN_NOTICE\"&gt;&gt;&gt; my timer handler here &lt;&lt;&lt;\\n\"); my_need_sched = 1;//此时置my_need_sched为1 &#125; time_count++;#endif return;&#125;void my_schedule(void)&#123; tPCB *next; tPCB *prev;//定义即将要发生切换的任务 //错误处理 if(my_current_task == NULL||my_current_task-&gt;next == NULL) &#123; return; &#125; printk(KERN_NOTICE \"&gt;&gt;&gt;my_schedule&lt;&lt;&lt; \\n\"); next = my_cueernt_task-&gt;next; prev = my_current_task; if(next.state==0)//两个正在运行的进城之间进行切换 &#123; my_current_task = next; printk(KERN_NOTICE \"&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n\",prev-&gt;pid,next-&gt;pid); //切换进程，内嵌汇编代码 asm volatile( \"pushl %%ebp\\n\\t\" //save ebp \"movl %%esp,$0\\n\\t\" //save esp,prev执行到此，将当前的esp保存到prev的thread的sp \"movl $2,%%esp\" //将next的esp移入esp \"movl $1f,$1\" //将prev的eip压栈 \"pushl %3\\n\\t\" \"ret\\n\\t\" \"1:\\t\" :\"=m\"(prev-&gt;thread.sp),\"=m\"(prev-&gt;thread.ip) :\"m\"(next-&gt;thread.sp),\"m\"(next-&gt;thread.ip) &#125; else//next 是一个新进程，重来没有执行过，所以初始的堆栈是空的 &#123; next.state=0 my_current_task = next; printk(KERN_NOTICE \"&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n\",prev-&gt;pid,next-&gt;pid); //切换进程，内嵌汇编代码 asm volatile( \"pushl %%ebp\\n\\t\" //save ebp \"movl %%esp,$0\\n\\t\" //save esp,prev执行到此，将当前的esp保存到 \"movl $2,%%esp\" //将next的esp移入esp \"movl $2,%%ebp\" //第一次执行，next的堆栈是空的 \"movl $1f,$1\" //将prev的eip压栈 \"pushl %3\\n\\t\" \"ret\\n\\t\" \"1:\\t\" :\"=m\"(prev-&gt;thread.sp),\"=m\"(prev-&gt;thread.ip) :\"m\"(next-&gt;thread.sp),\"m\"(next-&gt;thread.ip) &#125;&#125; 分析：在进程（prev）切换到下一个进程（next）时，可以分为两种情况：（1）next进程的运行状态为0（正在运行），觉得此处可以理解为，起初，next已经执行部分，在next的执行时发生过切换，切换给prev运行，此时我们想将next切换回来（两个正在进行的进程进行切换）。所以，将正在执行的my_ current task改为next，在切换前保存现场，将ebp压栈，将当前的esp（这里的esp我觉得是prev执行到的位置，在切换之前要保存下来，保存到prev-&gt;thread.sp中），将next-&gt;thread.sp赋值到esp中（可以理解为接着next上次执行停下来的位置接着执行），保存prev-&gt;thread.ip，将next-&gt;thread.ip压栈，在ret，接着执行的就是nexr的eip，完成了两个正在运行的进程间的切换。（2）next从来没有执行过，此处可以理解为next是一个新进程，它还没有自己的运行堆栈等信息，所以与上的主要区别就在于next-&gt;thread.sp要同时赋值给next的esp和ebp，用于创建next的运行堆栈，其余相似。同样在ret后开始执行next的eip。现在来看何时会发生调度？发生调度有两个if，第一个if要求i%10000000 == 0，第二个if要求my need sched == 1，在my timer handler()中，time count%1000 == 0 &amp;&amp; my need sched != 1会将my need sched置1，所以一定会有某个进程进入调度函数。调度的主要目的就是完成上下文的切换，不同的进程task的pid是不同的，eip为task[pid].thread.ip=(unsigned int)my _ process，my_process中输出不同的pid，所以可以查看进程切换的结果。实验结果如下： 三、总结在这次试验中我理解了操作系统的工作方式，其中进程切换是操作系统最核心的功能，进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器 的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。 这次的实验学到很多东西，希望在之后的实验学习中会有更多的收获。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"新学期学习计划","date":"2017-02-27T11:43:25.000Z","path":"2017/02/27/新学期计划/","text":"盲目的学了快3周的时间，感觉每天学的都很零散，比如说今天看点http协议，明天看点css，后天就可能在想着爬虫的事，这样虽然每天看起来都在学习，但是效率感人，所以决定做个学习规划放在博客上，每周更新总结一次进度。 一、学习 我看书有个很不好的习惯，不喜欢做笔记，所以我决定之后每读一本书，都会写至少一篇读书笔记。 1.读书笔记目前的读书清单如下：1.JavaScript高级程序设计（这本书之前虽然已经读过一遍，不过现在很多地方都忘了，现在准备再将重点章节回顾一遍，然后对js做个系统的总结）2.图解HTTP（原计划上周看完的书，结果拖到这周还剩50页左右，这个月结束之前肯定可以读完，读完之后做个http协议相关内容的总结）3.You Don’t Know JS系列（很好的一套书，目前只读了前2本，希望能在4月份之前读完剩下的几本）4.深入浅出nodejs（先放一放，用这本书入门nodejs来说真的有点难，决定在写一些nodejs的小Demo之后再来研读这本书）5.高性能JavaScript（很好的一本书，但是可能最近没时间看了QAQ）6.JavaScript设计模式与开发实践（做完js的总结之后准备开始读这本书(^_^)）7.CSS揭秘（书很好，可以慢慢看，反正我是CSS渣渣）8.CSAPP（每次都没能坚持看完的书。。。。）9.算法导论、编程之美、剑指offer、面试宝典（找实习前简单过一遍） 2.百度IFE 百度IFE是一个面向大学生的前端技术学习平台,开课时间2月24-4月24希望能在4月份之前完成我想去学的大部分课程，之后我会在完成一门课后发表学习笔记，已经完成的几门课程，我也会抽个时间来做个总结。 二、代码1.框架的学习1.计划深入学习vue.js,包括vue的一系列全家桶，当然webpack和gulp这些打包工具肯定也包含在内。2.nodejs的话准备学习koa，计划在这学期结束前做个vue全家桶+koa的项目，了解下前后端分离和接口设计这些实际项目中需要用到的东西3.计划去了解react native和weex，不一定要达到深入的程度，但是最起码要了解这些东西的基本原理。4.计划去深入学习一到两门数据库语言，包括但不限于mongoDB，MySQL。。。 写在最后，这份计划我会在每周一的晚上进行更新，包括更新学习进度，增删学习计划等。最后，希望我能在这学期结束前完成这份计划。不多说，好好学习，天天向上！","tags":[{"name":"心情","slug":"心情","permalink":"http://tpioneer.github.io/tags/心情/"}]},{"title":"Linux内核分析一 ——计算机如何工作","date":"2017-02-24T05:38:23.000Z","path":"2017/02/24/Linux内核分析一/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、存储程序计算机工作模型（1）冯诺依曼体系结构：存储程序计算机的工作模型从硬件角度看程序的执行过程：其中IP（instruction pointer）为CPU中的寄存器，指向内存中的某一块，CPU执行指令时，会从IP中取出一条指令后执行，执行过后，IP自加一（增加一个指令的长度），取下一条指令执行。 从程序员的角度看： CPU是一个大的for循环，不停地执行next instruction命令，存储器主要负责数据和代码等信息的存储，CPU与Main Memory通过总线进行连接。 需要注意的几点： 1.程序员不可以直接修改IP的值，只能通过一些指令，如CALL、RET、JMP等间接修改IP的值 2.IP在32位机器中表示为EIP（本次实验以32位作为分析），在64位机器则被中表示为RIP。 3.EIP是按指令递增，即在执行一条指令后递增1,不管当前指令是多少位的。 （2）x86汇编基础知识（32位机器）一.寄存器：在x86体系中，寄存器可分为通用寄存器、段寄存器、标志寄存器：1.通用寄存器: EAX:累加器 EBX:基地址寄存器 ECX:计数寄存器 EDX:数据寄存器 EBP:堆栈基指针 ESP:堆栈顶指针 ESI,EDI:变址寄存器 2.段寄存器： CS——代码段寄存器(Code Segment Register)，其值为代码段的段值； DS——数据段寄存器(Data Segment Register)，其值为数据段的段值； ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值； FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。 3.标志寄存器 32位和64位差别不大，通用寄存器扩展到64位，前边带R就是64位的，此外64位还增加了一些64位的MMX的寄存器。使用只是寄存器名字不一样，内部机制差别不大 二：汇编指令（以常见的MOV,PUSH,POP,CALL等进行说明）（1）MOV指令及寻址方式MOV指令操作如下：1.CPU内部寄存器之间数据的任意传送(除了码段寄存器CS和指令指针IP以外)。2.立即数传送至CPU内部的通用寄存器组(即AX、BX、CX、DX、BP、SP、SI、DI)，给这些寄存器赋初值。3.CPU内部寄存器(除了CS和IP以外)与存储器(所有寻址方式)之间的数据传送，可以实现一个字节或一个字的传送。4.能实现用立即数给存储单元赋初值。 movb,movw,movl,movq分别针对8位，16位，32位，64位系统 寻址方式如下：（1）寄存器寻址（不访问内存）movl %eax,%edx &lt;==&gt;edx= eax，将eax中的值赋值给edx（2）立即寻址（不访问内存）用$表示立即数movl $0x1234,%edx &lt;==&gt;edx = 0x1234（3）直接寻址movl 0x123,%edx &lt;==&gt;edx = (int32_t)0x123（4）间接寻址movl (%ebx),%edx &lt;==&gt;edx = (int32_t)ebx（5）变址寻址movl 4(%ebx),%edx &lt;==&gt;edx = (int32_t)(ebx+4)(2) pushl和pop指令，pushl用于入栈（栈的扩张），pop用于出栈（栈的收缩，栈是向下生长的，堆栈基指针ebp指向栈底，栈顶指针esp指向栈顶。入栈操作：pushl %eax完成的操作包括两步，先subl $4,%esp，再movl %eax,(%esp)出栈操作：pop %eax完成的操作包括两步，先movl (%esp)，%eax，再addl $4,%esp（3）CALL主要用于函数调用，如调用0x1234处的函数，即先push %eip，再movl %0x1234,%eip。（4）RET指令用于恢复操作，完成pop %eip操作（5）enter和leave操作enter 为置空栈操作，可以理解为先pushl %ebp，再movl %esp,%ebp，而leave用于撤销函数调用堆栈，即先movl %ebp,%esp，再popl %ebp 注意：（1）函数调用堆栈是由逻辑上多个堆栈叠加起来的（比如函数的嵌套）（2）函数的返回值默认使用eax寄存器存储返回给上一级函数 二、汇编一个简单的c程序分析其汇编指令执行过程先编写一个main.c的小程序，程序代码如下所示：使用gcc –S –o main.s main.c -m32指令将main.c编译成汇编代码保存在main.s中，main.s如下所示：进入main.s汇编文件，去掉所有以.开始的代码行（以.开始的代码是连接时的辅助信息）得到纯汇编代码如下：12345678910111213141516171819202122232425g: pushl %ebp movl %esp, %ebp movl 8(%ebp), %eax addl $2, %eax popl %ebp retf: pushl %ebp movl %esp, %ebp subl $4, %esp movl 8(%ebp), %eax movl %eax, (%esp) call g leave retmain: pushl %ebp movl %esp, %ebp subl $4, %esp movl $4, (%esp) call f addl $6, %eax leave ret 初始时，esp和ebp均指向栈顶，即地址为为0位置，汇编代码的入口也为main函数，从main函数开始分析如下：1.执行完pushl %ebp后，esp-4指向地址1，ebp位置不变；接着执行movl %esp, %ebp，将esp的地址赋给ebp，此时esp和ebp均指向地址1；再执行subl $4, %esp和movl $4, (%esp)，先esp-4，即esp地址向下移动一位，指向2，再将4这个值存放到地址2处2.执行call f,执行call时实际执行两个动作，pushl %eip ; movl f ,%eip,即将eip压栈，eip指向的是23行代码，同时跳转到f执行，注意这里esp会接着向下移动一位，即esp指向地址3，然后跳转到f中执行。3.在f中执行完pushl %ebp后，esp-4指向地址4，ebp位置不变扔指向1将ebp1的内容压入3中，在执行过movl%esp，%ebp后，esp和ebp置于相同的标号处（4）,接着执行subl $4，%esp，esp向下移动到地址5，movl 8(%ebp),%eax 变址寻址，将ebp（此处为标号4）加8（向上移动两个标号，也就是标号2处）的值赋给eax，所以%eax = 4;接着执行movl %eax,(%esp)，将eax的内容也就是4赋值到esp下也就是标号5处 。4.执行call，此时eip指向第15行代码leave的位置,并由eip指向g跳转到g中去执行5.在g中执行pushl %ebp同上，将esp向下移动，将ebp（标号为4）压栈 ，esp为6；和在f中分析方法一样，movl %esp,%ebp ，esp和ebp指向相同的位置6，ebp向上移动两个标号的值（也就是4）赋给eax，%eax中存放的值为4，addl操作，将eax的值与立即数2相加，结果为6，将6存回到eax ，popl %ebp,将ebp的值放回到ebp，执行效果：ebp重新指向标号为4的位置,同时esp减4（向上移动一位指向5）6.ret执行popl %eip，也就是说esp向上移动指向5的标号的位置，同时eip指向15行指令的位置（call的下一条指令）7.回到f中执行，leave相当于执行两条指令，首先，将esp指向ebp相同的位置（也就是标号4的位置），popl %ebp，将ebp出栈，此时ebp指回标号1的位置，由于popl，esp向上移动一位。ret执行popl %eip，由于popl，esp向上移动一位，指向标号2，eip指向第23行代码处8.eip执行第23行代码，回到main中，执行eax此时的值为6，执行addl，6+6 = 12，将12存回到eax。执行leave，分为两步， movl %ebp，%esp，将esp指向ebp的位置，popl %ebp，将ebp出栈（ebp指向0的位置），popl指令时esp向上移动，也就是说esp，ebp均指向标号0的位置，栈回到main函数最初的状态。 ret，return的是main函数之前的堆栈至此，小程序运行完毕。通过下面的图片可以更清晰的观察这一过程： 三、实验总结–对计算机如何工作的理解计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停止指令。简单来说就是CPU负责处理和运算，存储器负责保存指令和数据。通过操作系统得调度和安排，不停地进行取址、译码、执行的循环。冯诺依曼体系结构的核心就是存储和控制流程，预先要把指挥计算机如何进行操作的指令序列（称为程序）和原始数据通过输入设备输送到计算机内存贮器中。每一条指令中明确规定了计算机从哪个地址取数，进行什么操作，然后送到什么地址去等步骤。计算机之所以能自动，正确的按人们的意图工作，是由于人们事先已把计算机如何工作的程序和原始数据通过输入设备送到计算机的存储器中。当计算机执行时，控制器就把这些指令一条接一条地从存储器中取出来，加以翻译，并按指令的要求进行相应的操作，直到遇到停止指令或发生计算机无法继续运行的情况为止。其实计算机就是个很单纯的机器，我们写好了让它可以读懂的语言，它才能够按照我们的命令去一步步执行！所以，好好学习，天天向上吧！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"前端入门笔记一——html5语义化标签","date":"2017-02-22T05:56:31.000Z","path":"2017/02/22/前端入门笔记（一）/","text":"关键词： html5 语义化 前端 前言 首先，这篇文章并不是介绍html的所有标签，这里仅仅是对html5中新定义的一系列语义化标签如&lt;header&gt;,&lt;nav&gt;,&lt;section&gt;等的一个简单 的汇总，这些语义化的标签的出现，不仅提高了开发效率，同时相对于使用过多的div，这些标签的出现极大的增强了页面的语义化。下面总结了一 些常用的语义化标签。 header标签header 标签定义文档的页眉（介绍信息），通常是一些引导和导航信息。整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素。 示例如下：1234&lt;header&gt;&lt;p&gt;this is the page Logo&lt;/p&gt;&lt;nav&gt;this is page navigation&lt;/nav&gt;&lt;/header&gt; footer标签footer 标签定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等123&lt;footer&gt; COPYRIGHT@Tpioneer&lt;/footer&gt; nav标签nav 标签定义显示导航链接不是所有的成组的超级链接都需要放在nav标签里。nav标签里应该放入一些当前页面的主要导航链接。 例如在页脚显示一个站点的导航链接（如首页，服务信息页面，版权信息页面等等），就可以使用nav标签，当然，这不是必须的 示例如下：1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; article标签article标签装载显示一个独立的文章内容。例如一篇完整的论坛帖子，一则网站新闻，一篇博客文章等等，一个用户评论等等。artilce可以嵌套，则内层的artilce对外层的article标签有隶属的关系，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论。在这里需要注意的是，article标签的内容独立于文档的其余部分。 示例如下：123456&lt;article&gt; &lt;h1&gt;文章标题&lt;/h1&gt; 这是一篇文章 &lt;article&gt;评论1...&lt;/article&gt; &lt;article&gt;评论2...&lt;/article&gt;&lt;/article&gt; aside标签aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 示例如下：1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;广告&lt;/h1&gt; &lt;p&gt;今日头条&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; section标签section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。section使用注意：一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。表示文档中的节或者段；article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div。 示例如下：1234567891011&lt;section&gt; &lt;h1&gt;section&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; time标签time是文本标签，用来标记一篇文章的发布时间。示例如下：1&lt;time datetime=\"2017-02-15\" pubdate&gt;2017年02月15日&lt;/time&gt; figure标签figure标签规定独立的流内容（图像、图表、照片、代码等等）。figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 示例如下：12345&lt;figure&gt; &lt;p&gt;黄浦江上的的卢浦大桥&lt;/p&gt; &lt;p&gt;拍摄者：W3School 项目组，拍摄时间：2010 年 10 月&lt;/p&gt; &lt;img src=\"/i/shanghai_lupu_bridge.jpg\" width=\"350\" height=\"234\" /&gt;&lt;/figure&gt; 总结以上这些标签都是html5中新出现的语义化标签，在定义有语义的内容时，优先选择语义化标签而不是div，例如页眉用header，导航用nav，页脚用footer等等。当然这也不是说div标签就没有意义了，因为div是没有任何意义的元素，它只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。","tags":[{"name":"前端","slug":"前端","permalink":"http://tpioneer.github.io/tags/前端/"}]},{"title":"HEXO搭建你的专属博客","date":"2017-02-21T15:33:56.000Z","path":"2017/02/21/HEXO搭建你的专属博客/","text":"关键词：github hexo blog STEP1 前期准备 在这里默认你已经拥有了github账号，如果没有，还等什么，赶快加入最大的同性交友平台吧（雾。 在github中创建一个名为username.github.io（这里的username即你的账号名，比如我的为Tpioneer.github.io）的库，创建完 后可以试着往库中push一个简单的index.html如下。（github的简单操作可以参考如下教程） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 接着在你的浏览器中输入https://username.github.io/（username为你的账号名），如果没什么问题的话即可访问到Hello World。 同时，需要安装git，可以去官网下载。 STEP2 hexo环境配置与安装 hexo是一款基于Node.js的静态博客框架, 在安装hexo之前，我们需要先安装node.js,这里对安装不做过多介绍，官网的文档已经很详细了。 Node和Git都安装好后,首先创建一个blog文件夹,然后进入blog目录来安装Hexo（windows用户推荐用Git Bash）。执行如下命令安装Hexo： sudo npm install -g hexo 安装完成后，执行init命令初始化hexo,命令： hexo init然后等待安装完成，即完成了hexo的安装。 安装完成后需要对hexo进行配置，找到/hexo/_config.yml文件，用任意编辑器打开该文件，拉到最后找到Deployment,将其改为下图所示内容： 这里有个需要注意的点，在冒号后面一定要空格，否则识别不出来 修改头像，同样需要打开_config.yml ，找到 avatar: 这一行，然后添加头像的URL就行了，当然你也可以将头像图片放入hexo/source/img目录下，然后将配置改为如下：avatar: /img/xxx.jpg 同理可以修改你的博客名，博客描述，作者等信息，这里发一张我的参考配置如下： 当然配置文件中还有很多其他的配置选项，在这里就不一一赘述了，官网上提供了更详细的参考资料 STEP3 hexo的部署和常用命令 部署步骤如下(建议在每次重新部署时都执行一次hexo clean)： hexo clean hexo generate (hexo g) hexo deploy (hexo d)在部署完成后，在你的浏览器中输入https://username.github.io/，大功告成，撒花★,°:.☆(￣▽￣)/$:.°★ 。 当然，这只是简单的部署了属于你自己的一个blog，你还需要稍微再花费点时间让你的blog更加丰富多彩。 首先，你需要了解下面提供的一些常用命令： hexo new “postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 了解了这些命令，相信你写一些简单的blog已经没有什么问题了，但是中庸的官方主题肯定不会让你特别喜欢。这里有个主题集合,你可以在这里尽情挑选你喜欢的主题，每个主题的github中都有相应的文档，所以，大胆的去尝试吧，相信你一定能找到适合你的那个。 最后，送上一份Markdown的语法说明书,还等什么，赶快开启你的私人blog之旅吧!","tags":[{"name":"学习","slug":"学习","permalink":"http://tpioneer.github.io/tags/学习/"}]}]