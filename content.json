[{"title":"Linux内核分析一 ——计算机如何工作","date":"2017-02-24T05:38:23.000Z","path":"2017/02/24/Linux内核分析一/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、存储程序计算机工作模型（1）冯诺依曼体系结构：存储程序计算机的工作模型从硬件角度看程序的执行过程：其中IP（instruction pointer）为CPU中的寄存器，指向内存中的某一块，CPU执行指令时，会从IP中取出一条指令后执行，执行过后，IP自加一（增加一个指令的长度），取下一条指令执行。 从程序员的角度看： CPU是一个大的for循环，不停地执行next instruction命令，存储器主要负责数据和代码等信息的存储，CPU与Main Memory通过总线进行连接。 需要注意的几点： 1.程序员不可以直接修改IP的值，只能通过一些指令，如CALL、RET、JMP等间接修改IP的值 2.IP在32位机器中表示为EIP（本次实验以32位作为分析），在64位机器则被中表示为RIP。 3.EIP是按指令递增，即在执行一条指令后递增1,不管当前指令是多少位的。 （2）x86汇编基础知识（32位机器）一.寄存器：在x86体系中，寄存器可分为通用寄存器、段寄存器、标志寄存器：1.通用寄存器: EAX:累加器 EBX:基地址寄存器 ECX:计数寄存器 EDX:数据寄存器 EBP:堆栈基指针 ESP:堆栈顶指针 ESI,EDI:变址寄存器 2.段寄存器： CS——代码段寄存器(Code Segment Register)，其值为代码段的段值； DS——数据段寄存器(Data Segment Register)，其值为数据段的段值； ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值； FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。 3.标志寄存器 32位和64位差别不大，通用寄存器扩展到64位，前边带R就是64位的，此外64位还增加了一些64位的MMX的寄存器。使用只是寄存器名字不一样，内部机制差别不大 二：汇编指令（以常见的MOV,PUSH,POP,CALL等进行说明）（1）MOV指令及寻址方式MOV指令操作如下：1.CPU内部寄存器之间数据的任意传送(除了码段寄存器CS和指令指针IP以外)。2.立即数传送至CPU内部的通用寄存器组(即AX、BX、CX、DX、BP、SP、SI、DI)，给这些寄存器赋初值。3.CPU内部寄存器(除了CS和IP以外)与存储器(所有寻址方式)之间的数据传送，可以实现一个字节或一个字的传送。4.能实现用立即数给存储单元赋初值。 movb,movw,movl,movq分别针对8位，16位，32位，64位系统 寻址方式如下：（1）寄存器寻址（不访问内存）movl %eax,%edx &lt;==&gt;edx= eax，将eax中的值赋值给edx（2）立即寻址（不访问内存）用$表示立即数movl $0x1234,%edx &lt;==&gt;edx = 0x1234（3）直接寻址movl 0x123,%edx &lt;==&gt;edx = (int32_t)0x123（4）间接寻址movl (%ebx),%edx &lt;==&gt;edx = (int32_t)ebx（5）变址寻址movl 4(%ebx),%edx &lt;==&gt;edx = (int32_t)(ebx+4)(2) pushl和pop指令，pushl用于入栈（栈的扩张），pop用于出栈（栈的收缩，栈是向下生长的，堆栈基指针ebp指向栈底，栈顶指针esp指向栈顶。入栈操作：pushl %eax完成的操作包括两步，先subl $4,%esp，再movl %eax,(%esp)出栈操作：pop %eax完成的操作包括两步，先movl (%esp)，%eax，再addl $4,%esp（3）CALL主要用于函数调用，如调用0x1234处的函数，即先push %eip，再movl %0x1234,%eip。（4）RET指令用于恢复操作，完成pop %eip操作（5）enter和leave操作enter 为置空栈操作，可以理解为先pushl %ebp，再movl %esp,%ebp，而leave用于撤销函数调用堆栈，即先movl %ebp,%esp，再popl %ebp 注意：（1）函数调用堆栈是由逻辑上多个堆栈叠加起来的（比如函数的嵌套）（2）函数的返回值默认使用eax寄存器存储返回给上一级函数 二、汇编一个简单的c程序分析其汇编指令执行过程先编写一个main.c的小程序，程序代码如下所示：使用gcc –S –o main.s main.c -m32指令将main.c编译成汇编代码保存在main.s中，main.s如下所示：进入main.s汇编文件，去掉所有以.开始的代码行（以.开始的代码是连接时的辅助信息）得到纯汇编代码如下：12345678910111213141516171819202122232425g: pushl %ebp movl %esp, %ebp movl 8(%ebp), %eax addl $2, %eax popl %ebp retf: pushl %ebp movl %esp, %ebp subl $4, %esp movl 8(%ebp), %eax movl %eax, (%esp) call g leave retmain: pushl %ebp movl %esp, %ebp subl $4, %esp movl $4, (%esp) call f addl $6, %eax leave ret 初始时，esp和ebp均指向栈顶，即地址为为0位置，汇编代码的入口也为main函数，从main函数开始分析如下：1.执行完pushl %ebp后，esp-4指向地址1，ebp位置不变；接着执行movl %esp, %ebp，将esp的地址赋给ebp，此时esp和ebp均指向地址1；再执行subl $4, %esp和movl $4, (%esp)，先esp-4，即esp地址向下移动一位，指向2，再将4这个值存放到地址2处2.执行call f,执行call时实际执行两个动作，pushl %eip ; movl f ,%eip,即将eip压栈，eip指向的是23行代码，同时跳转到f执行，注意这里esp会接着向下移动一位，即esp指向地址3，然后跳转到f中执行。3.在f中执行完pushl %ebp后，esp-4指向地址4，ebp位置不变扔指向1将ebp1的内容压入3中，在执行过movl%esp，%ebp后，esp和ebp置于相同的标号处（4）,接着执行subl $4，%esp，esp向下移动到地址5，movl 8(%ebp),%eax 变址寻址，将ebp（此处为标号4）加8（向上移动两个标号，也就是标号2处）的值赋给eax，所以%eax = 4;接着执行movl %eax,(%esp)，将eax的内容也就是4赋值到esp下也就是标号5处 。4.执行call，此时eip指向第15行代码leave的位置,并由eip指向g跳转到g中去执行5.在g中执行pushl %ebp同上，将esp向下移动，将ebp（标号为4）压栈 ，esp为6；和在f中分析方法一样，movl %esp,%ebp ，esp和ebp指向相同的位置6，ebp向上移动两个标号的值（也就是4）赋给eax，%eax中存放的值为4，addl操作，将eax的值与立即数2相加，结果为6，将6存回到eax ，popl %ebp,将ebp的值放回到ebp，执行效果：ebp重新指向标号为4的位置,同时esp减4（向上移动一位指向5）6.ret执行popl %eip，也就是说esp向上移动指向5的标号的位置，同时eip指向15行指令的位置（call的下一条指令）7.回到f中执行，leave相当于执行两条指令，首先，将esp指向ebp相同的位置（也就是标号4的位置），popl %ebp，将ebp出栈，此时ebp指回标号1的位置，由于popl，esp向上移动一位。ret执行popl %eip，由于popl，esp向上移动一位，指向标号2，eip指向第23行代码处8.eip执行第23行代码，回到main中，执行eax此时的值为6，执行addl，6+6 = 12，将12存回到eax。执行leave，分为两步， movl %ebp，%esp，将esp指向ebp的位置，popl %ebp，将ebp出栈（ebp指向0的位置），popl指令时esp向上移动，也就是说esp，ebp均指向标号0的位置，栈回到main函数最初的状态。 ret，return的是main函数之前的堆栈至此，小程序运行完毕。通过下面的图片可以更清晰的观察这一过程： 三、实验总结–对计算机如何工作的理解计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停止指令。简单来说就是CPU负责处理和运算，存储器负责保存指令和数据。通过操作系统得调度和安排，不停地进行取址、译码、执行的循环。冯诺依曼体系结构的核心就是存储和控制流程，预先要把指挥计算机如何进行操作的指令序列（称为程序）和原始数据通过输入设备输送到计算机内存贮器中。每一条指令中明确规定了计算机从哪个地址取数，进行什么操作，然后送到什么地址去等步骤。计算机之所以能自动，正确的按人们的意图工作，是由于人们事先已把计算机如何工作的程序和原始数据通过输入设备送到计算机的存储器中。当计算机执行时，控制器就把这些指令一条接一条地从存储器中取出来，加以翻译，并按指令的要求进行相应的操作，直到遇到停止指令或发生计算机无法继续运行的情况为止。其实计算机就是个很单纯的机器，我们写好了让它可以读懂的语言，它才能够按照我们的命令去一步步执行！所以，好好学习，天天向上吧！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"前端入门笔记一——html5语义化标签","date":"2017-02-22T05:56:31.000Z","path":"2017/02/22/前端入门笔记（一）/","text":"关键词： html5 语义化 前端 前言 首先，这篇文章并不是介绍html的所有标签，这里仅仅是对html5中新定义的一系列语义化标签如&lt;header&gt;,&lt;nav&gt;,&lt;section&gt;等的一个简单 的汇总，这些语义化的标签的出现，不仅提高了开发效率，同时相对于使用过多的div，这些标签的出现极大的增强了页面的语义化。下面总结了一 些常用的语义化标签。 header标签header 标签定义文档的页眉（介绍信息），通常是一些引导和导航信息。整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素。 示例如下：1234&lt;header&gt;&lt;p&gt;this is the page Logo&lt;/p&gt;&lt;nav&gt;this is page navigation&lt;/nav&gt;&lt;/header&gt; footer标签footer 标签定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等123&lt;footer&gt; COPYRIGHT@Tpioneer&lt;/footer&gt; nav标签nav 标签定义显示导航链接不是所有的成组的超级链接都需要放在nav标签里。nav标签里应该放入一些当前页面的主要导航链接。 例如在页脚显示一个站点的导航链接（如首页，服务信息页面，版权信息页面等等），就可以使用nav标签，当然，这不是必须的 示例如下：1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; article标签article标签装载显示一个独立的文章内容。例如一篇完整的论坛帖子，一则网站新闻，一篇博客文章等等，一个用户评论等等。artilce可以嵌套，则内层的artilce对外层的article标签有隶属的关系，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论。在这里需要注意的是，article标签的内容独立于文档的其余部分。 示例如下：123456&lt;article&gt; &lt;h1&gt;文章标题&lt;/h1&gt; 这是一篇文章 &lt;article&gt;评论1...&lt;/article&gt; &lt;article&gt;评论2...&lt;/article&gt;&lt;/article&gt; aside标签aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 示例如下：1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;广告&lt;/h1&gt; &lt;p&gt;今日头条&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; section标签section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。section使用注意：一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。表示文档中的节或者段；article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div。 示例如下：1234567891011&lt;section&gt; &lt;h1&gt;section&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; time标签time是文本标签，用来标记一篇文章的发布时间。示例如下：1&lt;time datetime=\"2017-02-15\" pubdate&gt;2017年02月15日&lt;/time&gt; figure标签figure标签规定独立的流内容（图像、图表、照片、代码等等）。figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 示例如下：12345&lt;figure&gt; &lt;p&gt;黄浦江上的的卢浦大桥&lt;/p&gt; &lt;p&gt;拍摄者：W3School 项目组，拍摄时间：2010 年 10 月&lt;/p&gt; &lt;img src=\"/i/shanghai_lupu_bridge.jpg\" width=\"350\" height=\"234\" /&gt;&lt;/figure&gt; 总结以上这些标签都是html5中新出现的语义化标签，在定义有语义的内容时，优先选择语义化标签而不是div，例如页眉用header，导航用nav，页脚用footer等等。当然这也不是说div标签就没有意义了，因为div是没有任何意义的元素，它只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。","tags":[{"name":"前端","slug":"前端","permalink":"http://tpioneer.github.io/tags/前端/"}]},{"title":"HEXO搭建你的专属博客","date":"2017-02-21T15:33:56.000Z","path":"2017/02/21/HEXO搭建你的专属博客/","text":"关键词：github hexo blog STEP1 前期准备 在这里默认你已经拥有了github账号，如果没有，还等什么，赶快加入最大的同性交友平台吧（雾。 在github中创建一个名为username.github.io（这里的username即你的账号名，比如我的为Tpioneer.github.io）的库，创建完 后可以试着往库中push一个简单的index.html如下。（github的简单操作可以参考如下教程） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 接着在你的浏览器中输入https://username.github.io/（username为你的账号名），如果没什么问题的话即可访问到Hello World。 同时，需要安装git，可以去官网下载。 STEP2 hexo环境配置与安装 hexo是一款基于Node.js的静态博客框架, 在安装hexo之前，我们需要先安装node.js,这里对安装不做过多介绍，官网的文档已经很详细了。 Node和Git都安装好后,首先创建一个blog文件夹,然后进入blog目录来安装Hexo（windows用户推荐用Git Bash）。执行如下命令安装Hexo： sudo npm install -g hexo 安装完成后，执行init命令初始化hexo,命令： hexo init然后等待安装完成，即完成了hexo的安装。 安装完成后需要对hexo进行配置，找到/hexo/_config.yml文件，用任意编辑器打开该文件，拉到最后找到Deployment,将其改为下图所示内容： 这里有个需要注意的点，在冒号后面一定要空格，否则识别不出来 修改头像，同样需要打开_config.yml ，找到 avatar: 这一行，然后添加头像的URL就行了，当然你也可以将头像图片放入hexo/source/img目录下，然后将配置改为如下：avatar: /img/xxx.jpg 同理可以修改你的博客名，博客描述，作者等信息，这里发一张我的参考配置如下： 当然配置文件中还有很多其他的配置选项，在这里就不一一赘述了，官网上提供了更详细的参考资料 STEP3 hexo的部署和常用命令 部署步骤如下(建议在每次重新部署时都执行一次hexo clean)： hexo clean hexo generate (hexo g) hexo deploy (hexo d)在部署完成后，在你的浏览器中输入https://username.github.io/，大功告成，撒花★,°:.☆(￣▽￣)/$:.°★ 。 当然，这只是简单的部署了属于你自己的一个blog，你还需要稍微再花费点时间让你的blog更加丰富多彩。 首先，你需要了解下面提供的一些常用命令： hexo new “postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 了解了这些命令，相信你写一些简单的blog已经没有什么问题了，但是中庸的官方主题肯定不会让你特别喜欢。这里有个主题集合,你可以在这里尽情挑选你喜欢的主题，每个主题的github中都有相应的文档，所以，大胆的去尝试吧，相信你一定能找到适合你的那个。 最后，送上一份Markdown的语法说明书,还等什么，赶快开启你的私人blog之旅吧!","tags":[{"name":"学习","slug":"学习","permalink":"http://tpioneer.github.io/tags/学习/"}]}]