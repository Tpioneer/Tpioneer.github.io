[{"title":"Linux内核分析八","date":"2017-04-16T12:36:03.000Z","path":"2017/04/16/Linux内核分析八/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、理论知识1)、进程切换的关键代码switch_to1.进程调度与进程调度的时机（1）进程分类：I/O型（执行块，频繁）CPU型（大量的计算）（2）调度策略：什么时候选择以怎样的方式执行新进程（3）Linux中的优先级是动态的，Linux进程根据优先级排队（4）进程调度的时机中断处理过程（包括时钟中断、I/O中断、系统调用和异常）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()（也就是说，用户态进程只能被动地调度）；内核线程可以直接调用schedule()进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度，即在中断处理过程中进行调度。2.进程切换上下文的代码（1）进程切换：内核有能力挂起正在CPU上执行的进程，并恢复以前挂起的某个进程的执行（2）进程上下文包含了进程执行需要的所有信息用户地址空间：包括程序代码，数据，用户堆栈等控制信息：进程描述符，内核堆栈等硬件上下文（中断也要保存硬件上下文只是保存的方法不同，中断是通过压栈来解决的，而这里是通过schedule函数）（3）schedule()函数，选择一个新进程运行context_switch完成进程上下文切换switch_to：切换寄存器和堆栈保存当前进程的eip，把下一个进程的eip压栈 2)、Linux系统的一般执行过程1.Linux系统的一般执行过程分析正在运行的用户态进程X切换到运行用户态进程Y的过程正在运行的用户态进程X发生中断——save cs:eip/esp/eflags(current) to kernel stack；then load cs:eip(系统调用的起点，entry of a specific ISR) and ss:esp(point to kernel stack)进入内核代码，SAVE_ALL //保存现场中断处理过程中或中断返回前调用了schedule()（可能不发生，诺发生，则其中的switch_to做了关键的进程上下文切换）标号1之后开始运行上一步中选中的用户态进程Y(这里Y曾经通过以上步骤被切换出去过因此可以从标号1继续执行)restore_all //恢复现场iret - pop cs:eip/ss:esp/eflags from kernel stack继续运行用户态进程Y2.Linux系统执行过程中的几个特殊情况通过中断处理过程中的调度时机，用户态进程与内核线程之间互相切换和内核线程之间互相切换，与最一般的情况非常类似，只是内核线程运行过程中发生中断的时候没有进程用户态和内核态的转换，cs不会变化；内核线程主动调用schedule()，只有进程上下文的切换，没有发生中断上下文的切换，也不需要从中断中返回，与最一般的情况相比更简略；创建子进程的系统调用在子进程中的执行起点（如ret_from_fork，上文中也已经提到过)及返回用户态；加载一个新的可执行程序后返回到用户态的情况，如execve，在新进程内部修改了中断保存的信息3.内核（1）进程的地址空间一共有4G，3G以上只有内核态可以访问，0至3G用户态可以访问（2）每一个进程都可以陷入内核，然后返回用户态，没有进程就空转 3）、Linux操作系统架构和执行过程概览1.linux操作系统架构概览（1）操作系统：计算机系统包含的一个基本的程序集合（2）目的：与硬件交互为用户程序提供一个良好的执行环境2.执行ls命令在控制台输入ls命令Shell程序分析输入参数，确定这是ls调用系统调用fork生成一个shell本身的拷贝调用exec系统调用将ls可执行文件装入内存从系统调用返回Shell和ls都得到执行3.从CPU和内存角度看Linux系统执行执行gets()函数；执行系统调用，陷入内核；等待输入，CPU会调度其他进程执行，同时wait一个I/O中断；敲击ls，发I/O中断给CPU，中断处理程序进行现场保存、压栈等等；中断处理程序发现X进程在等待这个I/O（此时X已经变成阻塞态），处理程序将X设置为WAKE_UP;进程管理可能会把进程X设置为next进程，这样gets系统调用获得数据，再返回用户态堆栈从内存角度看，所有的物理地址都会被映射到3G以上的地址空间：因为这部分对所有进程来说都是共享的 二、实验gdb开始调试，设置监视、加载文件符号表调试并设置断点set break ponit at schedule context_switch switch to在schedule处断点可以看到函数如下图 三、总结最一般的情况：正在运行的用户态进程X切换到运行用户态进程Y的过程 (1)正在运行的用户态进程X(2)发生中断——savecs:eip/esp/eflags(current) to kernel stack,then load cs:eip(entry of a specificISR) and ss:esp(point to kernel stack).(3)SAVE_ALL //保存现场(4)中断处理过程中或中断返回前调用了schedule()，其中的switch_to做了关键的进程上下文切换(5)标号1之后开始运行用户态进程Y(这里Y曾经通过以上步骤被切换出去过因此可以从标号1继续执行)(6)restore_all //恢复现场(7)iret - pop cs:eip/ss:esp/eflags from kernel stack(8)继续运行用户态进程Y","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析七","date":"2017-04-09T11:22:19.000Z","path":"2017/04/09/Linux内核分析七/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、基础理论1、编译链接的过程和ELF可执行文件格式1.1 编译链接的过程源文件生成可执行文件的过程主要包括三个部分：预处理：主要是编译器对各种预处理命令进行处理，包括头文件的包含、宏定义的扩展、条件编译的选择等；编译：把作为中间结果的汇编代码翻译成了机器代码，即目标代码，不过它还不可以运行；链接：链接是处理可重定位文件，把它们的各种符号引用和符号定义转换为可执行文件中的合适信息（一般是虚拟内存地址）的过程。链接又分为静态链接和动态链接，前者是程序开发阶段程序员用ld（gcc实际上在后台调用了ld）静态链接器手动链接的过程，而动态链接则是程序运行期间系统调用动态链接器(ld-linux.so)自动链接的过程分析：以hello.c源文件为例 （1）预处理阶段：gcc -E -o hello.cpp hello.c -m32 将hello.c文件预处理成hello.cpp文件；预处理负责把include的文件包含进来及宏替换等工作。 （2） 编译阶段：gcc -x cpp-output -S -o hello.s hello.cpp -m32 将hello.cpp文件编译成hello.s汇编代码 （3）链接阶段：gcc -x assembler -c hello.s -o hello.o -m32 将目标文件链接成可执行文件hello1.2 ELF可执行文件格式 ELF文件由4部分组成：ELF头（ELF header）、程序头表（Program header table）、节（Section）和节头表（Section header table）。实际上，一个文件中不一定包含全部内容，而且他们的位置也未必如同所示这样安排，只有ELF头的位置是固定的，其余各部分的位置、大小等信息由ELF头中的各项值来决定。 一个ELF头文件在文件的开始，保存了路线图（road map），描述了该文件的组织情况。程序头表（program header table）告诉系统如何来创建一个进程的内存映像。Section头表（section header table）包含了描述文件sections的信息。每个section在这个表中有一个入口；每个入口给出了该section的名字，大小。 当创建或增加一个进程映像的时候，系统在理论上将拷贝一个文件的段到一个虚拟的内存段。ELF可执行文件分为三种：一个可重定位（relocatable）文件保存着代码和适当的数据用来和其他的object文件一起来创建一个可执行文件或者一个共享文件；主要是.o文件；一个可执行文件（executable）文件保存着一个用来执行的程序；该文件指出了exec（BA_OS）如何来创建程序进程映像；一个共享object文件保存着代码和合适的数据，用来被下面的两个链接器链接。第一个是连接编辑器，可以和其他的可重定位和共享object文件来创建其他的object。第二个是动态链接器，联合一个可执行文件和其他的共享object文件来闯进一个进程映像。主要是.so文件。Elf header格式代码如下：1234567891011121314151617typedef struct&#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx; lf32_Ehdr; &#125; 数据类型说明： 2、静态链接和动态链接2.1 静态链接 静态链接在程序的编译期完成的链接。 静态链接的ELF可执行文件与进程的地址空间，ELF头文件地址：0x08048000 程序的实际入口：Entry point address：0x08048300；可执行文件加载带内存中开始执行的第一行代码。一般静态链接会将所有代码放在一个代码段。2.2 动态链接 动态链接在程序的运行期完成的链接。 动态链接分为可执行程序装载时动态链接和运行时动态链接。 二、实验过程1 打开实验楼虚拟机环境，进入LinuxKernel文件夹，然后替换menu重新编译， 使用qemu命令进入跟踪调试环境，设置断点：sys_execve，如下图所示： 2 执行程序，进入sys_execve系统调用，单步执行sys_execve系统调用的指令，如下图所示： 3 执行start_thread函数，这里的new_ip是返回到用户态的第一条指令的地址，在这里我们通过readelf命令，可以看到可执行文件hello的第一条指令地址就是：0x8048d0a 三、实验分析（1）内核是如何支持多种不同可执行文件格式的？ Load_elf_binary-&gt;start-thread中：调用这个函数是实现修改内核堆栈中EIP的值作为新程序的起点。New_id是通过start_thread函数中第二个参数elf_entry来传递。（2）命令行参数和环境变量是如何保存和传递到新程序堆栈的？ 新创建一个用户态堆栈的时候，实际上是把命令行参数的内容和环境变量的内容通过指针的方式传递到系统调用内核处理函数，然后内核处理函数创建出一个新的用户态堆栈的时候，会把参数和变量拷贝到用户态堆栈中。先函数调用参数传递，再系统调用参数传递。如果仅仅是加载一个静态链接的可执行程序的话，我们只需要传递一个命令行参数和环境变量即可。但对于大多数程序来说，需要加载动态链接。（3）为什么execve系统调用返回后新的可执行程序能顺利执行？ Execve系统调用过程也是很特殊的系统调用过程。子进程是从ret_from_fork开始执行然后返回用户态。当执行到execve系统调用的时候陷入内核态，在内核里面，sys_execve函数会利用execve加载的可执行文件把当前进程的可执行程序给覆盖掉，系统调用返回的时候，返回的已经不是原来的可执行程序了，而是新的可执行程序的起始位置（一般是新可执行程序的main()函数处）。（4）对于静态链接的可执行程序和动态链接的可执行程序execve系统调用返回时会有什么不同？ sys_execve系统调用的处理过程 do_execve(getname(filename),argv,envp)//getname是传递文件名，argv,envp是传递环境变量。把环境变量转化为结构之后，再调用do_execve_common(filename,argv,envp)函数。（5）“Linux内核装载和启动一个可执行程序”的理解Linux内核装载一个可执行程序：首先创建新进程，该进程通过execve()系统调用执行指定的ELF文件，再调用execve()系统调用对应的内核的入口函数sys_execve()，sys_execve()服务例程修改当前进程的执行上下文。 上述步骤完成后，该进程开始执行可执行文件代码。当ELF被load_elf_binary()装载完成后，函数返回至do_execve()在返回至sys_execve()。ELF可执行文件的入口点取决于程序的链接方式，对于静态链接的可执行文件，若是静态链接的，elf_entry就是指向可执行文件里边规定的那个头部，即main函数对应的位置，若这个可执行文件是需要依赖其它动态链接库的话，则elf_entry就是指向动态链接器的起点。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Machine Learning---1st week","date":"2017-04-05T05:37:09.000Z","path":"2017/04/05/Machine-Learning-1st-week/","text":"这一系列博客是记录我在学习coursera上的机器学习课程时做的一些笔记和自己的一些理解。 第一周的课程分为3部分，Introduction，Linear Regression with One Variable和Linear Algebra Review，在学完之后，应该对机器学习有了一个大概的了解，当然，线性代数的基础是必不可少的。 Part 1 Introduction1.什么是机器学习？ 这里引用课程原文如下：Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition.Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”Example: playing checkers.E = the experience of playing many games of checkersT = the task of playing checkers.P = the probability that the program will win the next game.In general, any machine learning problem can be assigned to one of two broad classifications:Supervised learning and Unsupervised learning. 2.监督式学习和非监督式学习定义和区别？是否有监督（supervised），就看输入数据是否有标签（label）。输入数据有标签，则为有监督学习，没标签则为无监督学习。1）监督式学习监督式学习，我的理解就是在处理task之前先学习一个正确集或者说是训练集，即在去做tasks之前会有个学习历史数据的过程。比如说，一个小孩子第一次去动物园，他的父母会告诉他狮子是什么，老虎是什么，这样在下次去动物园时这个孩子就可以自己区分老虎和狮子。除了这种典型的分类问题，监督式学习还包括了回归问题，比如说根据最近一段时间的温度监控，来预测明天的温度，这就是个回归问题，因为温度是连续的，而如果是根据最近的天气来判断明天是晴天，下雨还是阴天，这就是个分类问题。2）非监督式学习还是先来问题化地解释一下无监督学习：我们有一些问题，但是不知道答案，我们要做的无监督学习就是按照他们的性质把他们自动地分成很多组，每组的问题是具有类似性质的（比如数学问题会聚集在一组，英语问题会聚集在一组，物理……..）。所有数据只有特征向量没有标签，但是可以发现这些数据呈现出聚群的结构，本质是一个相似的类型的会聚集在一起。把这些没有标签的数据分成一个一个组合，就是聚类（Clustering）。比如Google新闻，每天会搜集大量的新闻，然后把它们全部聚类，就会自动分成几十个不同的组（比如娱乐，科技，政治……），每个组内新闻都具有相似的内容结构。无监督学习还有一个典型的例子就是鸡尾酒会问题（声音的分离），在这个酒会上有两种声音，被两个不同的麦克风在不同的地方接收到，而可以利用无监督学习来分离这两种不同的声音。注意到这里是无监督学习的原因是，事先并不知道这些声音中有哪些种类（这里的种类就是标签的意思）。 Part 2 Linear Regression with One VariablePart 3 Linear Algebra ReviewConclusion","tags":[{"name":"ML","slug":"ML","permalink":"http://tpioneer.github.io/tags/ML/"}]},{"title":"Linux内核分析六","date":"2017-04-02T08:58:15.000Z","path":"2017/04/02/Linux内核分析六/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、Linux中的进程简析进程是任何多道程序设计的操作系统额基本概念，就像我们经常看到的关于进程的定义就是程序执行的一个实例，也是系统资源调度的最小单位。如果同一个程序被多个用户同时运行，那么这个程序就有多个相对独立的进程，与此同时他们又共享相同的执行代码。在Linux系统中进程的概念类似于任务或者线程（task &amp; threads）。实际上我们说进程是一个程序运行时候的一个实例实际上说的是它就是一个一个可以充分描述程序以达到了其可以运行状态的的一个数据和代码集合。一个进程会被产生并会复制出自己的子代，类似细胞分裂一样。从系统的角度来看进程的任务实际上就是担当承载系统资源的单位，系统在调度和分配资源的时候也会以他们作为基本单位开始进行分配。（系统中的资源很多例如CPU的时间片、内存堆栈等等）我们知道程序或者进程执行的时候有的时候就会需要创建新的实例这个时候A如果新创建了B那么A就是B的父进程。实际上就是复制了几乎所有父进程的信息包括代码。子进程接收父进程地址空间的一个逻辑拷贝，（实际上就是可以理解为面向对象中的类创建实例的过程或者继承父类的这种关系，实际上他们看起来域属性是一样的但是又不会完全一样，所以我们说这里面是逻辑上的一个复制，后面会详细分析~）然后，这个子进程会从创建进程那个系统调用服务代码之后的下一条指令开始执行（ret_from_fork），执行代码与父进程是相同的。但是我们要知道实际上虽然AB都是指向相同的代码部分，但是正如我们知道的程序需要指令和数据，所以他们的数据拷贝是不同的，因此进程对一个内存单元的修改在AB之间是不可见的。以上是早期的时候情况，现代的系统实际上可能并不是这样的。在支持多线程应用的系统中很多拥有相对独立执行路径的用户程序共享应用程序的大部分数据结构。那么这样的话一个进程就是由几个用户线程组成，而且每一个执行线路就是一个线程。那么进程在系统中的数据结构又是什么样子的呢？首先最应该知道就是系统如何管理这些进程，那么系统一定要有相应的数据结构去标识每一个进程以及他们的扩展数据结构（这里可以想象一下进程标识可能不会涵盖具体的执行代码和数据集合可能它仅仅是包含指向这些代码段和数据段的入口地址或者说是指针，事实上也是这样）大体上想想可以知道实际上这个结构就是我们在操作系统中所说的PCB（Process Control Block）在Linux中这个数据结构我们叫做task_struct,我们想想它实际上至少应该包括以下信息，比如优先级，它的运行状态，他所在的内存空间，它的文件访问权限等等，下图是抽象图：task进程链表管理，tty控制台，fs文件系统，files打开的文件描述符，mm内存管理描述，signal进程间通信信号 Linux进程的状态与操作系统原理中的描述的进程状态似乎有所不同，比如就绪状态和运行状态都是TASK_RUNNING，为什么呢？fork创建好新进程变成就绪态，调度器选择了进程后变成运行态。但都是task running，状态相同。因为进程是taskrunning时是可运行的，有无在运行看进程是否在cpu实际执行，根据这个来划分就绪和运行态。正在运行进程调用do exit会变成taskzombie僵尸进程由系统处理掉；正在运行进程等待资源会进入阻塞态，可用时被唤醒进入就绪态。 1、进程的状态进程执行时，它会根据具体情况改变状态 。进程状态是调度和对换的依据。Linux中的进程主要有如下状态（上面图中的那个state字段）（1）可运行状态基于linux简洁优雅的性质，系统这里面不区分执行和ready两个状态，只要进程处于资源充足状态，就可以运行或者随时可以准备执行。而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。（2）可中断的等待状态 进程被挂起，直到等到一个可以唤醒他的东西，例如一个硬件中断、某项系统资源、或一个信号量。当它等到这些唤醒条件的之后就会进入可运行状态。（3）不可中断的等待状态 实际上我们要理解为什么是不可中断的，一种常见的状态就是这个进程正在访问一个独占的临界资源，这种时候处于一种不可抢占的状态。通常当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或 SIGTTOU信号后就处于这种状态。例如，正接受调试的进程就处于这种状态。（4）跟踪状态 没什么说的，就是一个进程正在被另一个进程监视，比如我们在调试的时候。（5）僵死状态进程虽然已经终止，但由于某种原因，父进程还没有执行wait()系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际是系统中的垃圾，必须进行相应处理以释放其占用的资源。我们在设置这些状态的时候是可以直接用语句进行的比如：p—&gt;state = TASK_RUNNING。同时内核也会使用set_task_state和set_current_state。 关于thread_info进程是动态的，所以需要有效率的管理。Linux为每个进程分配一个8KB大小的内存区域，用于存放该进程两个不同的数据结构：Thread_info和进程的内核堆栈进程处于内核态时使用，不同于用户态堆栈，即PCB中指定了内核栈，那为什么PCB中没有用户态堆栈？用户态堆栈是怎么设定的？内核控制路径所用的堆栈很少，因此对栈和Thread_info来说，8KB足够了 2、进程的创建之前的分析中在linux启动过程中进程创建最后的rest_init时创建了两个kernel thread内核线程：1，kernel init最终去启动用户态进程init；2，启动了k_threadd是内核线程的demo。使用shell时，0号进程在linux写死，1号进程从当前进程复制一份进程描述符PCB,根据需要修改pid等内容，再加载init可执行程序。 进程是如何创建起来的？可能是复制后修改了一份成为了子进程，那子进程是从哪来启动的呢？先来分析shell命令行是如何创建一个子进程：fork（）用于在用户态创建一个子进程的系统调用。底下两个判断都会被执行，fork以后子父进程pid返回值不一样：子进程返回0；父进程返回子进程pid。从fork这里就变成了2个进程执行。 于父进程 fork 返回子进程号，对于子进程 fork 返回 0 ，这也是执行路径如此的原因所在。但是， fork 的返回不同值的原因又是什么，这就得看 fork 的实现了。fork 先是调用 find_empty_process 为子进程找到一个空闲的任务号，然后调用 copy_process 复制进程， fork 返回 copy_process 的返回值 last_pid ，也就是子进程号。从上面的实现看来， fork 的返回值不会是 0 ， last_pid 从 1 开始，父进程执行 if 外面的部分，上面的逻辑正是父进程的执行逻辑。对于子进程，先看子进程的初始状态， copy_process 中创造了子进程的上下文执行环境，这个上下文环境正是父进程 fork 系统调用时的环境，其中， p-&gt;tss.eip 正是被赋值为 fork 之后下一条指令地址，这就是子进程和父进程都返回到 fork 下一条指令处的原因。同时，需要注意的是， p-&gt;tss.eax 被赋了值 0 ，当调度到子进程开始执行时，首先加载其上下文环境， eip 被加载为 fork 之后下一条指令， eax 就被加载为 0 ，所以，对于子进程来说，和父进程唯一的区别就是返回值（ eax ）为 0 ，子进程执行 if 里面的部分。 二、实验过程首先我们要将新的menuOS放入我们的实验楼系统中，如下图所示然后我们看到我们把新的文件test_fork替换了之前的test.c文件因为里面我们加入了新的命令就是fork用于我们之后的运行调试，然后我们 make rootfs 制作很文件系统。然后我们就可以调试了。然后们开始设置一些主要的断点如下图:这里面我们看到我们设置了do_fork copy_process这样的断点，n是next的意思我们可以一条条执行这些代码。继续执行我们看到这里面会用一些条件判断和赋值的东西，比如将当先任务的thread_info是专为防止多处理器并发而引入的一种锁指向运行的那个模块之后将P指向的进程标识设为相应状态之后会设置一个自旋锁，这里面为什么要设置自旋锁呢？是专为防止多处理器并发而引入的一种锁， 三、总结可以看出，fork()中，内核并不立刻为新进程分配代码和数据物理内存页，新进程与父进程共同使用父进程已有的代码和数据物理内存页面。只有当以后执行过程中由一个进程一写方式访问内存时候被访问的内存页面才会在写操作之前被复制到新申请的内存页面中。另外在fork的最后是将任务设置成了就绪状态，由于fork（）是一个系统调用，在系统调用部分system_call.s，可以看到在系统函数返回后，会调用调度函数schedule（），在schedule()中，就会检测到新进程的就绪状态，并用switch_to()切换到新进程进行执行。 具体过程是：首先在内存中申请一页内存存放进程控制块task_struct，并返回进程号nr，并在task数组的nr处存放task_struct的指针，还要将task的当前指针current指到nr处；然后将父进程的task_struct的内容复制到新进程的task_struct中作为模版；之后我们对task_struct中的信息进行修改，主要进行一下工作：设置父进程、清除信号位图、时间片、运行时间、根据当前环境设置tss（内核态指针esp0指向task_struct所在页的顶端）、设置LDT的选择子等(根据nr指向GDT中相应的ldt描述符)。 在之后我们要设置新进程的代码段、数据段的基地址和段长：更新task_struct中的代码开始地址：更新task_struct中局部描述符表中的代码段和数据段描述符。然后再复制父进程的页表目录项和页表：在页目录表中，复制父进程的页表目录项，目的地址由新进程的线性地址计算出来；对每个对应的页表目录项申请一个空闲页，并用页表地址更新页表目录项，最后将父进程页表中各项复制到新进程对应的页表中，也就是说，这个时候，子进程与父进程共享物理内存。并且更新task_struct中的文件信息：文件打开次数加1，父进程的当前目录引用数加1。还要设置TSS和LDT描述符项：在全局描述符表（GDT）中设置新任务的TSS描述符项和LDT段的描述符项，使TSS描述符项和LDT描述符项分别指向task_struct的TSS结构和LDT结构。最后我们将任务设置为就绪状态，向当前进程（父进程）返回新进程号。最后总结一下，Linux进程的创建过程就是内存中进程相关资源产生的过程，就是clone的过程。例如task _struct、内核态堆栈、线型地址到物理地址的映射表、全局描述表（GDT）中的任务状态段，局部描述符表、代码段、堆、栈、参数全局变量等数据区什么的。上面提到的这几类资源中，很多都与task_struct有关，所以我想说一下task_struct。它是Linux的进程控制块，驻留在内存中，描述进程的基本信息，所以它是进程操作依据的重要数据结构。Linux中一般进程都是由现有的一个进程创建的，也就是我们所说的父进程，子进程。具体的创建是通过fork()实现的。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析五","date":"2017-03-26T02:24:33.000Z","path":"2017/03/26/Linux内核分析五/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、实践1.使用gdb跟踪分析4号系统调用内核函数：sys_write在test.c中增加我编写的两个函数：MyPrint()和MyPrintAsm(),这两个函数的作用是输出一条msg，代码如下：123456789101112131415161718192021int MyPrint() &#123; char* msg = \"Hello Linux\"; printf(\"%s\", msg); return 0; &#125;int MyPrintAsm() &#123; char* msg = \"Hello Linux\"; int len = 11; int result = 0; __asm__ __volatile__(\"movl %2, %%edx;\\n\\r\" \"movl %1, %%ecx;\\n\\r\" \"movl $1, %%ebx;\\n\\r\" \"movl $4, %%eax;\\n\\r\" \"int $0x80\" :\"=m\"(result) :\"m\"(msg),\"r\"(len) :\"%eax\"); return 0; &#125; 在main函数中增加两个函数的MenuConfig命令项：12MenuConfig(\"hello\",\"print hello info\",MyPrint);MenuConfig(\"hello-asm\",\"print hello info(asm)\",MyPrintAsm); 将修改后的menu放入LinuxKernel目录下，执行menu下的makefile编译运行menuOS，在MenuOS中输入help，可以查看当前所有的系统调用，分别执行hello、hello-asm进行系统调用，结果如下图所示： 二、调试内核1.使用gdb跟踪调试内核 qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -Sgdb（gdb）file linux-3.18.6/vmlinux（gdb）target remote:1234b sys_time：在系统调用time的位置设置断点c：在MenuOs里使用time，停在断点处s 单步调试—一步一步执行（PS：无法执行time_asm中的int 0X80部分） 调试如下所示：可以看到，在输入hello指令后，系统调用了sys_write函数来进行输出。 三、分析系统调用在内核代码中的处理过程1.系统调用在内核代码中的工作机制和初始化 main.c中start_kernel函数：trap_init()set_system_trap_gate(SYSCALL_VECTOR,&amp;system_call)SYSCALL_VECTOR：系统调用的中断向量&amp;system_call：汇编代码入口一执行int 0x80，系统直接跳转到system_call。 2.系统调用——一个特殊的中断 SAVE_ALL：保存现场call *sys_call_table(,%eax,4)调用了系统调度处理函数，eax存的是系统调用号，是实际的系统调度程序。sys_call_table：系统调用分派表syscall_after_all：保存返回值若有sys_exit_work，则进入sys_exit_work:会有一个进程调度时机。work_pending -&gt; work_notifysig，用来处理信号可能call schedule：进程调度代码可能跳转到restore_all，恢复现场。若无sys_exit_work，就执行restore_all恢复，返回用户态。INTERRUPT_RETURN &lt;=&gt; iret，结束。 在系统调用返回之前，可能发生进程调度，进程调度里就会出现进程上下文的切换。- 进程间通信可能有信号需要处理。- 可以将内核视为一系列中断指令的集合。 四、总结：从系统调用处理过程到一般的中断处理过程系统调用就是特殊的一种中断1.保存现场在系统调用时，我们需要SAVE_ALL，用于保存系统调用时的上下文。同样，中断处理的第一步应该也要保存中断程序现场。目的：在中断处理完之后，可以返回到原来被中断的地方，在原有的运行环境下继续正确的执行下去。2.确定中断信息在系统调用时，我们需要将系统调用号通过eax传入，通过sys_call_table查询到调用的系统调用。同样，中断处理时系统也需要有一个中断号，通过检索中断向量表，了解中断的类型和设备。3.处理中断跳转到相应的中断处理程序后，对中断进行处理。4.返回系统调用时最后要restore_all恢复系统调用时的现场，并用iret返回用户态。同样，执行完中断处理程序，内核也要执行特定指令序列，恢复中断时现场，并使得进程回到用户态。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析四","date":"2017-03-19T11:24:31.000Z","path":"2017/03/19/Linux内核分析四/","text":"一、预备知识（1）用户栈与内核栈内核栈：存在于内核空间，当进程在内核栈里运行时，CPU栈顶指针寄存器里面的内容是内核栈空间地址，使用内核栈。用户栈：存在于用户空间，当进程在用户栈里运行时，CPU栈顶指针寄存器里面的内容是用户栈空间地址，使用用户栈。（2）用户态与内核态用户态：用户在非特权模式下，访问会资源会受到限制。内核栈：用户在特权模式下，可随意访问资源为什么要区分用户态与内核态？因为在操作系统中有很多很重要的代码要保证安全性，不可被任意修改，区别用户态和内核态可访问的空间，保证了系统的安全，防止因不当操作而造成的系统崩溃。在Linux中有0和3两种运行级别：0表示内核态，3表示用户态 （3）利用地址空间区别内核态和用户态只有内核态可以访问0xc0000000以上的地址空间，0x00000000到0xbfffffff在两种状态下都可以访问（4）内核态与用户态的切换当进程因为硬件中断或者系统调用，而从用户态转变为内核态时，进程所使用的堆栈要从用户栈变为内核栈，此时进程进入内核态后，首先，在内核态上保存用户态堆栈上的地址，设置堆栈指针寄存器的内容为当前进程的内核栈地址，这样就完成了用户栈向内核栈的切换。当进程从内核态恢复到用户态时，将内核态保存的用户态的堆栈地址恢复到栈指针寄存器，这样就完成了内核态向用户态的切换。（5）系统调用1.系统调用与API（应用程序编程接口）区别API只是一个函数定义，而系统调用通过软中断向内核发出一个明确的请求。不是每个API都对应一个特定的系统调用。首先，API可能直接提供用户态的服务(比如一些数学函数)，其次，一个单独的API可能调用几个系统调用，不同的API可能调用了同一个系统调用。2.系统调用的优点系统调用为用户提供了调用与硬件设备等进行交互的接口，可以将用户从底层的硬件编程中解放出来，提高系统的安全性，是用户程序具有更好的可移植性。3.系统调用时执行的操作1）在进程的内核态堆栈中保存大多数寄存器的内容(即保存恢复进程到用户态执行所需要的上下文)2）根据用户态传递的系统调用号，确定系统调用的服务例程3）调用名为系统调用服务例程的相应的C函数来处理系统调用4）从系统调用返回 二、实验过程1.首先看下示例的time程序，代码如下所示：1234567891011#include &lt;stdio.h&gt;#include &lt;time.h&gt;int main()&#123; time_t tt; struct tm *t; tt = time(NULL); t = localtime(&amp;tt); printf(\"time:%d/%d/%d ,%d:%d:%d\\n\",t-&gt;tm_year+1900,t-&gt;tm_mon,t-&gt;tm_mday,t-&gt;tm_hour,t-&gt;tm_min,t-&gt;tm_sec); return 0;&#125; 用gcc time.c -o time -m32编译后，输出结果如下所示： 2.利用内嵌汇编代码的方式来实现上面的程序，代码如下所示： 程序执行结果如下： 3.实现一个简单的printf的程序，输出Hello，Linux,代码如下：12345678#include \"stdio.h\" #include \"string.h\" int main() &#123; char* msg = \"Hello Linux\"; printf(\"%s\", msg); return 0; &#125; 编译运行结果如下： 4.再用内嵌汇编代码的方式来实现printf，系统调用号为4，代码如下所示:1234567891011121314151617#include \"stdio.h\" #include \"string.h\" int main() &#123; char* msg = \"Hello Linux\"; int len = 11; int result = 0; __asm__ __volatile__(\"movl %2, %%edx;\\n\\r\" \"movl %1, %%ecx;\\n\\r\" \"movl $1, %%ebx;\\n\\r\"\\ \"movl $4, %%eax;\\n\\r\" \"int $0x80\" :\"=m\"(result) :\"m\"(msg),\"r\"(len) :\"%eax\"); return 0; &#125; 编译运行结果如下： 三、总结Linux 下的系统调用是通过中断（int 0x80）来实现的。在执行 int 80 指令时，寄存器 eax 中存放的是系统调用的功能号，而传给系统调用的参数则必须按顺序放到寄存器 ebx，ecx，edx，esi，edi 中，当系统调用完成之后，返回值可以在寄存器 eax 中获得。所有的系统调用功能号都可以在文件 /usr/include/bits/syscall.h 中找到，为了便于使用，它们是用 SYS_ 这样的宏来定义的，如 SYS_write、SYS_exit 等。例如，经常用到的 write 函数是如下定义的： ssize_t write(int fd, const void *buf, size_t count); 该函数的功能最终是通过 SYS_write 这一系统调用来实现的。根据上面的约定，参数 fb、buf 和 count 分别存在寄存器 ebx、ecx 和 edx 中，而系统调用号 SYS_write 则放在寄存器 eax 中，当 int 0x80 指令执行完毕后，返回值可以从寄存器 eax 中获得。或许你已经发现，在进行系统调用时至多只有 5 个寄存器能够用来保存参数，难道所有系统调用的参数个数都不超过 5 吗？当然不是，例如 mmap 函数就有 6 个参数，这些参数最后都需要传递给系统调用 SYS_mmap： void mmap(void start, size_t length, int prot , int flags, int fd, off_t offset); 当一个系统调用所需的参数个数大于 5 时，执行int 0x80 指令时仍需将系统调用功能号保存在寄存器 eax 中，所不同的只是全部参数应该依次放在一块连续的内存区域里，同时在寄存器 ebx 中保存指向该内存区域的指针。系统调用完成之后，返回值仍将保存在寄存器 eax 中。由于只是需要一块连续的内存区域来保存系统调用的参数，因此完全可以像普通的函数调用一样使用栈(stack)来传递系统调用所需的参数。但要注意一点，Linux 采用的是 C 语言的调用模式，这就意味着所有参数必须以相反的顺序进栈，即最后一个参数先入栈，而第一个参数则最后入栈。如果采用栈来传递系统调用所需的参数，在执行int 0x80 指令时还应该将栈指针的当前值复制到寄存器 ebx中。今天的实验可以形象化的将其记忆为：系统调用可以看成三层皮：API函数，system_ call,sys _xxx()系统调用服务例程。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析三——跟踪分析Linux内核的启动过程","date":"2017-03-12T12:18:04.000Z","path":"2017/03/12/Linux内核分析三/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、基础知识（1）Linux内核中常用的目录arch/ 是体系结构相关的代码，其中的/x86 文件夹下的内容是x86体系结构相关代码，是内核分析的重要分析目标。init/ 是内核启动相关的代码，是本文的重点分析对象。/init/main.c 文件是内核启动的起点，是分析内核启动流程的首要分析对象。fs/ 文件系统（file system?）kernel/ 内核相关的代码，一些内核中使用到的结构体、函数等重要对象的定义都在这里面。mm/ 内存管理的相关代码（memory managment?） （2）使用gdb调试工具的基本指令1.gdb 可执行文件名：进入gdb调试2.（gdb）l：相当于list，从第一行开始列出源码3.（gdb）回车：重复上一次指令4.（gdb）break 函数名/行数：在某一行或者某个函数处设置断点5.（gdb）info break:查看断点信息6.在断点内可以使用：r（run运行）,n（next单句执行）,c（contiune继续执行）7.（gdb）bt:查看函数堆栈8.（gdb）finis:退出函数9.（gdb）q:退出gdb （3）Linux内核启动过程Linux系统的启动分为4个部分：引导加载程序（bootloader）,Linux内核，文件系统，应用程序，其中，在Linux内核启动时我们完成了系统的重要初始化，并创建了init进程。 内核启动主要可以分为两个阶段：第一阶段主要是与硬件相关的初始化工作，这次我们讨论的主要是第二部分。 在内核源码的init/main.c中，定义了内核启动的入口函数start_kernel(),在start _kernel()中调用相关处理程序函数， 创建了0号进程（set _task _stack _end _magic(&amp;init _task)）， 设置体系结构的相关环境（setup _arch）, 初始化内存结构（bootmem _init）, 开启mmu， 建立页表（paging _init）, 初始化串口（console _init）， 0号进程是所有进程的父进程，0号进程创建了1号进程init，又创建了其他服务例程。 二、实验执行——通过gdb调试，分析Linux的内核启动过程（1）实验步骤：1.使用实验楼已配置好的环境， cd LinuxKernel/qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img 2.进入gdb调试： qemu -kernel linux-3.18.6/arch/x86/boot/bzImage -initrd rootfs.img -s -S其中：-S 是指在初始化cpu之前将cpu冻结-s 是指在-gdb tcp ：：1234，创建一个gdb server 另开一个shell窗口：（gdb）file linux-3.18.6/vmlinux （gdb）target remote:1234（gdb）break start_kernel（gdb）c !在start_kernel处设置断点，执行c调试，冻结的系统开始启动,断点执行到start _kernel,start_kernel()函数是一切的起点，在这个函数被调用之前都是系统的初始化工作（汇编语言），所以对内核的启动分析一般都从这个函数开始；main.c中没有main函数，start_kernel()这个函数就相当于是c程序中的main函数。下面从这个函数开始对内核的启动流程进行分析。首先，是init_task,它其实就是一个task_struct，与用户进程的task_struct一样， task_struct中保存了一个进程的所有基本信息，如进程状态，栈起始地址，进程号pid等；init_task的特殊之处在于它的pid=0,也就是通常所说的0号进程,在创建了0号进程之后，start_kernel()函数继续调用各个系统模块进行各种初始化之类的工作，比如： trap_init()完成中断向量的相关设置调用mm_init()完成内存管理的设置调用sched_init()完成调度模块的初始化 若设置断点在rest_init,这样子就调用了另一个非常重要的函数rest_init()，它的位置在/linux-3.18.6/init/main.c，其代码如下：123456789101112131415161718192021222324252627393static noinline void __init_refok rest_init(void)394&#123;395 int pid;396397 rcu_scheduler_starting();398 /*399 * We need to spawn init first so that it obtains pid 1, however400 * the init task will end up wanting to create kthreads, which, if401 * we schedule it before we create kthreadd, will OOPS.402 */403 kernel_thread(kernel_init, NULL, CLONE_FS);404 numa_default_policy();405 pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);406 rcu_read_lock();407 kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);408 rcu_read_unlock();409 complete(&amp;kthreadd_done);410411 /*412 * The boot idle thread must execute schedule()413 * at least once to get things moving:414 */415 init_idle_bootup_task(current);416 schedule_preempt_disabled();417 /* Call into cpu_idle with preempt disabled */418 cpu_startup_entry(CPUHP_ONLINE);419&#125; rest_init()函数中这行代码： kernel_thread(kernel_init, NULL, CLONE_FS);这个函数的功能是创建一个内核线程,kernel_thread函数中第一个参数是一个函数指针，也就是说内核此时fork出了一个新进程来执行kernel_init函数（低版本内核中这个函数名为init，为了区分init进程所以将其改为了kernel_init）;在kernel_init函数(/linux-3.18.6/init/main.c)正式启动了init进程,也就是1号进程。在kernel _init中，调用了run _init _process ()，默认的init是根目录下的init，如果在根目录下没有，则找/sbin/init,/etc/init,/bin/init,/bin/sh作为1号进程，则kernel init创建了一个1号进程， 执行kernel thread（kernel threaddd,NULL,CLONE FS|CLONE FILES）,创建内核线程管理系统的运行资源，在rest init()尾部，进入了cpu startup entry(…),进入cpu idle,执行cpu idle _ loop(),在cpu idle loop()进行while(1)的循环处理，这就是0号进程。当系统没有进程需要执行时就调度到idle进程 ,start_kernel()启动时rest _init就一直存在，也就是0号进程，0号进程创建了1号进程，还创建了其他的服务线程，这样内核就启动起来了。 三、实验总结本次实验主要分析了在内核启动过程中的第一个函数：start_kernel的执行。startkernel（）是init/main.c第一个启动的函数，主要完成了很多重要的与硬件平台相关和内核相关的初始化，并创建了init进程。 在init的start kernel()中调用了setup_ arch()进行与体系结构相关的第一个初始化， 通过bottom_init()函数根据系统定义的meminfo结构进行内存初始化， 最后paging_init()开启mmu，创建内核页表，映射所有的物理内存和I/O空间， 完成了创建异常向量表和初始化中断处理函数，初始化系统核心进程调度器和时钟中断处理机制，初始化串口控制台（serialconsole）等等， 当所有的相关操作结束后，start kernel（）会调用rest_ init()进行最后初始化，包括创建系统的第一个进程——init进程，init进程首先进行一系列的硬件初始化，然后通过命令行传递过来的参数挂在根文件系统，init进程会执行用户传递过来的参数执行用户指定的命令或者执行/sbin/init,/etc/init,/bin/init,/bin/sh 之一完成初始化工作，cpu_idle会被调用使系统处于闲置状态并等待用户输入。这次实验重点在于linux中启动过程的进程产生于分析，正如孟宁老师所说，“道生一（start_kernel….cpu_idle），一生二（kernel_init和kthreadd），二生三（即前面0、1和2三个进程），三生万物（1号进程是所有用户态进程的祖先，2号进程是所有内核线程的祖先），这些“都符合中国传统文化精神了”，也就不难让人理解了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"Linux内核分析二——操作系统如和工作","date":"2017-03-05T12:27:43.000Z","path":"2017/03/05/Linux内核分析二/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、理论知识1.计算机是如何工作的？——总结关键的三点（1）存储计算机模型——计算机系统中最最基础的数据结构（2）函数调用堆栈——高级语言得以运行的基础堆栈完成了计算机的基本功能：函数的参数传递机制和局部变量存取（3）中断：多道程序操作系统的基点 2.堆栈：C语言运行时必须记得调用路径和调用参数空间（1）堆栈的基本功能：函数调用框架、传递参数（32位）、保存返回地址（如eax保存返回值/内存地址）、提供局部变量空间（2）与堆栈相关的寄存器：esp和ebp 与堆栈相关的操作：push（入栈时esp指针会减4）、pop（出栈时esp指针会加4）（3）CS：eip总是指向下一条指令的地址 3.堆栈的工作过程（1）函数堆栈的形成过程函数的堆栈框架由下图展示： （2）函数堆栈框架的形成过程 二、实验内容——通过编一个简单的时间片轮转多道程序内核代码理解操作系统的进程上下文切换等 （1）实验过程、代码以及截图1.实验步骤：在实验楼的虚拟机中打开shell，执行12345678cd LinuxKernel/linux-3.9.4rm -rf mykernel //删除已存在的旧文件patch -p1 &lt; ../mykernel_for_linux3.9.4sc.patch //为内核打补丁,新增自己添加的功能make allnoconfigmake //编译过程时间较长//编译成功后执行qemu -kernel arcj/x86/boot/bzImage 2.实验结果如下：可以看到每当i增加100000会执行（printf函数输出my start kernel _ here …）时会触发一次时钟中断，在由时钟中断处理函数输出（&gt;..&gt;&gt;my_timer_handler&lt;&lt;…&lt;）代码实现如下：myinterrupt.c中实现了时钟处理函数 （2）设计一个简单的时间片轮转多道程序这个实验简单的模拟实现了一个操作系统的进程调度首先，创建一个mypcb.h的头文件，该头文件用于声明会用到的结构体以及函数（实验的相关代码可从），代码如下：1234567891011121314151617181920212223//最多任务数量#define MAX_TASK_NUM 4//内核堆栈大小#define KERNEL_STACK_SIZE 1024*8//定义结构体储存信息struct Thread&#123; unsigned int ip;//用于记录eip的值 unsigned int sp;//用于记录esp的值&#125;;//定义进程控制块，用于记录进程的相关信息typedef struct PCB&#123; unsigned int pid;//pid唯一标识 volatile long state; //进程的状态，-1没有运行，0正在运行，&gt;0停止 char stack[KERNEL_STACK_SIZE]; struct Thread thread; unsigned long task_entry;//进行的函数入口 struct PCB *next;//将进程连接起来&#125;tPCB;//调度函数void my_schedule(); 将mymain.c进行修改（主要是修改__init my _start _kernel()函数），完成基本的创建0号线程，创建其他线程并赋予线程信息，主要代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include \"mypcb.h\"tPCB task[TASK_MAX_NUM];tPCB *my_current_task;//当前任务的指针volatile int my_need_sched = 0; void my_process(void);void __init my_start_kernel(void)&#123; //初始化当前0号进程 int pid = 0; int i; task[pid].state=0; //正在运行的eip task[pid].thread.ip=(unsigned int)my_process task[pid].thread.sp=(unsigned long)&amp;task[pid].stack[KERNEL_STACK_SIZE-1]; task[pid].task_entry = &amp;task[pid].thread.ip; task[pid].next=&amp;task[pid]; //创建其他进程 for(i=1;i&lt;MAX_TASK_NUM;i++) &#123; //复制0号进程的信息 memcpy(&amp;task[i],&amp;task[0],sizeof(tPCB)); task[i].pid = i; task[i].state=-1;//没有运行 task[i].thread.sp=(unsigned long)&amp;task[i].stack[KERNEL_STACK_SIZE-1]; //链接，尾部插入 task[i].next=task[i-1].next; task[i-1].next = task[i]; &#125; //启动0号进程 pid=0; my_current_task=&amp;task[pid]; //内嵌汇编代码，执行保护现场和恢复现场 asm volatile( \"movl %1,%%esp\\n\\t\" //保存thread.sp-----&gt;esp \"pushl %1\\n\\t\"//将thread.sp压栈 \"pushl %0\\n\\t\"//将thread.ip入栈 \"ret\\n\\t\" //将eip弹出 //当前的eip为task[pid].thread.ip=(unsigned int)my_process，所以执行my_process() \"popl %%ebp\\n\\t\"//执行结束，恢复现场 : :\"c\"(task[pid].thread.ip),\"d\"(task[pid].thread.sp) );&#125;void my_process(void)&#123; int i=0; while(1) &#123; i++; if(i%10000000 == 0) &#123; //active schedule //every 10000000 execute printk(KERN_NOTICE\"this is process %d-\\n\",my_current_task-&gt;pid); if(my_need_sched == 1) &#123; my_need_sched = 0; my_schedule(); &#125; printk(KERN_NOTICE\"this is process %d+\\n\",my_current_task-&gt;pid); &#125; &#125;&#125; 在这个地方：0号进程的启动：（0号进程是第一个启动的进程）将esp置为当前进程的esp，然后将esp的值压栈，与ebp形成0号进程的自己的堆栈空间，将0号进程的task[pid].thread.ip也压栈，ret后，此时0号进程开始执行。当0号进程启动时，my current task指向task[0]，此时要执行0号进程的 task entry,task[pid].task entry = &amp;task[pid].thread.ip,当前的eip为task[pid].thread.ip=(unsigned int)my process，所以执行my process(), 在my process中有一个while(1)循环，my need _ sched的初始值是0。接着看my_interrupt.c函数，找到调度何时会发生。 修改my_interrupt.c:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include \"mypcb.h\"extern tPCB task[MAX_TASK_NUM];extern tPCB *my_current_task;extern volatile int my_need_sched;volatile int time_count = 0;//计时器/* * Called by timer interrupt. */void my_timer_handler(void)&#123;#if 1 if(time_count%1000 == 0 &amp;&amp; my_need_sched != 1) &#123; printk(KERN_NOTICE\"&gt;&gt;&gt; my timer handler here &lt;&lt;&lt;\\n\"); my_need_sched = 1;//此时置my_need_sched为1 &#125; time_count++;#endif return;&#125;void my_schedule(void)&#123; tPCB *next; tPCB *prev;//定义即将要发生切换的任务 //错误处理 if(my_current_task == NULL||my_current_task-&gt;next == NULL) &#123; return; &#125; printk(KERN_NOTICE \"&gt;&gt;&gt;my_schedule&lt;&lt;&lt; \\n\"); next = my_cueernt_task-&gt;next; prev = my_current_task; if(next.state==0)//两个正在运行的进城之间进行切换 &#123; my_current_task = next; printk(KERN_NOTICE \"&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n\",prev-&gt;pid,next-&gt;pid); //切换进程，内嵌汇编代码 asm volatile( \"pushl %%ebp\\n\\t\" //save ebp \"movl %%esp,$0\\n\\t\" //save esp,prev执行到此，将当前的esp保存到prev的thread的sp \"movl $2,%%esp\" //将next的esp移入esp \"movl $1f,$1\" //将prev的eip压栈 \"pushl %3\\n\\t\" \"ret\\n\\t\" \"1:\\t\" :\"=m\"(prev-&gt;thread.sp),\"=m\"(prev-&gt;thread.ip) :\"m\"(next-&gt;thread.sp),\"m\"(next-&gt;thread.ip) &#125; else//next 是一个新进程，重来没有执行过，所以初始的堆栈是空的 &#123; next.state=0 my_current_task = next; printk(KERN_NOTICE \"&gt;&gt;&gt;switch %d to %d&lt;&lt;&lt;\\n\",prev-&gt;pid,next-&gt;pid); //切换进程，内嵌汇编代码 asm volatile( \"pushl %%ebp\\n\\t\" //save ebp \"movl %%esp,$0\\n\\t\" //save esp,prev执行到此，将当前的esp保存到 \"movl $2,%%esp\" //将next的esp移入esp \"movl $2,%%ebp\" //第一次执行，next的堆栈是空的 \"movl $1f,$1\" //将prev的eip压栈 \"pushl %3\\n\\t\" \"ret\\n\\t\" \"1:\\t\" :\"=m\"(prev-&gt;thread.sp),\"=m\"(prev-&gt;thread.ip) :\"m\"(next-&gt;thread.sp),\"m\"(next-&gt;thread.ip) &#125;&#125; 分析：在进程（prev）切换到下一个进程（next）时，可以分为两种情况：（1）next进程的运行状态为0（正在运行），觉得此处可以理解为，起初，next已经执行部分，在next的执行时发生过切换，切换给prev运行，此时我们想将next切换回来（两个正在进行的进程进行切换）。所以，将正在执行的my_ current task改为next，在切换前保存现场，将ebp压栈，将当前的esp（这里的esp我觉得是prev执行到的位置，在切换之前要保存下来，保存到prev-&gt;thread.sp中），将next-&gt;thread.sp赋值到esp中（可以理解为接着next上次执行停下来的位置接着执行），保存prev-&gt;thread.ip，将next-&gt;thread.ip压栈，在ret，接着执行的就是nexr的eip，完成了两个正在运行的进程间的切换。（2）next从来没有执行过，此处可以理解为next是一个新进程，它还没有自己的运行堆栈等信息，所以与上的主要区别就在于next-&gt;thread.sp要同时赋值给next的esp和ebp，用于创建next的运行堆栈，其余相似。同样在ret后开始执行next的eip。现在来看何时会发生调度？发生调度有两个if，第一个if要求i%10000000 == 0，第二个if要求my need sched == 1，在my timer handler()中，time count%1000 == 0 &amp;&amp; my need sched != 1会将my need sched置1，所以一定会有某个进程进入调度函数。调度的主要目的就是完成上下文的切换，不同的进程task的pid是不同的，eip为task[pid].thread.ip=(unsigned int)my _ process，my_process中输出不同的pid，所以可以查看进程切换的结果。实验结果如下： 三、总结在这次试验中我理解了操作系统的工作方式，其中进程切换是操作系统最核心的功能，进行进程切换就是从正在运行的进程中收回处理器，然后再使待运行进程来占用处理器。这里所说的从某个进程收回处理器，实质上就是把进程存放在处理器 的寄存器中的中间数据找个地方存起来，从而把处理器的寄存器腾出来让其他进程使用。让进程来占用处理器，实质上是把某个进程存放在私有堆栈中寄存器的数据（前一次本进程被中止时的中间数据）再恢复到处理器的寄存器中去，并把待运行进程的断点送入处理器的程序指针PC，于是待运行进程就开始被处理器运行了，也就是这个进程已经占有处理器的使用权了。 在切换时，一个进程存储在处理器各寄存器中的中间数据叫做进程的上下文，所以进程的切换实质上就是被中止运行进程与待运行进程上下文的切换。 这次的实验学到很多东西，希望在之后的实验学习中会有更多的收获。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"新学期学习计划","date":"2017-02-27T11:43:25.000Z","path":"2017/02/27/新学期计划/","text":"盲目的学了快3周的时间，感觉每天学的都很零散，比如说今天看点http协议，明天看点css，后天就可能在想着爬虫的事，这样虽然每天看起来都在学习，但是效率感人，所以决定做个学习规划放在博客上，每周更新总结一次进度。 一、学习 我看书有个很不好的习惯，不喜欢做笔记，所以我决定之后每读一本书，都会写至少一篇读书笔记。 1.读书笔记目前的读书清单如下：1.JavaScript高级程序设计（这本书之前虽然已经读过一遍，不过现在很多地方都忘了，现在准备再将重点章节回顾一遍，然后对js做个系统的总结）2.图解HTTP（原计划上周看完的书，结果拖到这周还剩50页左右，这个月结束之前肯定可以读完，读完之后做个http协议相关内容的总结）3.You Don’t Know JS系列（很好的一套书，目前只读了前2本，希望能在4月份之前读完剩下的几本）4.深入浅出nodejs（先放一放，用这本书入门nodejs来说真的有点难，决定在写一些nodejs的小Demo之后再来研读这本书）5.高性能JavaScript（很好的一本书，但是可能最近没时间看了QAQ）6.JavaScript设计模式与开发实践（做完js的总结之后准备开始读这本书(^_^)）7.CSS揭秘（书很好，可以慢慢看，反正我是CSS渣渣）8.CSAPP（每次都没能坚持看完的书。。。。）9.算法导论、编程之美、剑指offer、面试宝典（找实习前简单过一遍） 2.百度IFE 百度IFE是一个面向大学生的前端技术学习平台,开课时间2月24-4月24希望能在4月份之前完成我想去学的大部分课程，之后我会在完成一门课后发表学习笔记，已经完成的几门课程，我也会抽个时间来做个总结。 二、代码1.框架的学习1.计划深入学习vue.js,包括vue的一系列全家桶，当然webpack和gulp这些打包工具肯定也包含在内。2.nodejs的话准备学习koa，计划在这学期结束前做个vue全家桶+koa的项目，了解下前后端分离和接口设计这些实际项目中需要用到的东西3.计划去了解react native和weex，不一定要达到深入的程度，但是最起码要了解这些东西的基本原理。4.计划去深入学习一到两门数据库语言，包括但不限于mongoDB，MySQL。。。 写在最后，这份计划我会在每周一的晚上进行更新，包括更新学习进度，增删学习计划等。最后，希望我能在这学期结束前完成这份计划。不多说，好好学习，天天向上！","tags":[{"name":"心情","slug":"心情","permalink":"http://tpioneer.github.io/tags/心情/"}]},{"title":"Linux内核分析一 ——计算机如何工作","date":"2017-02-24T05:38:23.000Z","path":"2017/02/24/Linux内核分析一/","text":"陶先锋 原创作品转载请注明出处 《Linux内核分析》MOOC课程 http://mooc.study.163.com/course/USTC-1000029000 一、存储程序计算机工作模型（1）冯诺依曼体系结构：存储程序计算机的工作模型从硬件角度看程序的执行过程：其中IP（instruction pointer）为CPU中的寄存器，指向内存中的某一块，CPU执行指令时，会从IP中取出一条指令后执行，执行过后，IP自加一（增加一个指令的长度），取下一条指令执行。 从程序员的角度看： CPU是一个大的for循环，不停地执行next instruction命令，存储器主要负责数据和代码等信息的存储，CPU与Main Memory通过总线进行连接。 需要注意的几点： 1.程序员不可以直接修改IP的值，只能通过一些指令，如CALL、RET、JMP等间接修改IP的值 2.IP在32位机器中表示为EIP（本次实验以32位作为分析），在64位机器则被中表示为RIP。 3.EIP是按指令递增，即在执行一条指令后递增1,不管当前指令是多少位的。 （2）x86汇编基础知识（32位机器）一.寄存器：在x86体系中，寄存器可分为通用寄存器、段寄存器、标志寄存器：1.通用寄存器: EAX:累加器 EBX:基地址寄存器 ECX:计数寄存器 EDX:数据寄存器 EBP:堆栈基指针 ESP:堆栈顶指针 ESI,EDI:变址寄存器 2.段寄存器： CS——代码段寄存器(Code Segment Register)，其值为代码段的段值； DS——数据段寄存器(Data Segment Register)，其值为数据段的段值； ES——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； SS——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值； FS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值； GS——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值。 3.标志寄存器 32位和64位差别不大，通用寄存器扩展到64位，前边带R就是64位的，此外64位还增加了一些64位的MMX的寄存器。使用只是寄存器名字不一样，内部机制差别不大 二：汇编指令（以常见的MOV,PUSH,POP,CALL等进行说明）（1）MOV指令及寻址方式MOV指令操作如下：1.CPU内部寄存器之间数据的任意传送(除了码段寄存器CS和指令指针IP以外)。2.立即数传送至CPU内部的通用寄存器组(即AX、BX、CX、DX、BP、SP、SI、DI)，给这些寄存器赋初值。3.CPU内部寄存器(除了CS和IP以外)与存储器(所有寻址方式)之间的数据传送，可以实现一个字节或一个字的传送。4.能实现用立即数给存储单元赋初值。 movb,movw,movl,movq分别针对8位，16位，32位，64位系统 寻址方式如下：（1）寄存器寻址（不访问内存）movl %eax,%edx &lt;==&gt;edx= eax，将eax中的值赋值给edx（2）立即寻址（不访问内存）用$表示立即数movl $0x1234,%edx &lt;==&gt;edx = 0x1234（3）直接寻址movl 0x123,%edx &lt;==&gt;edx = (int32_t)0x123（4）间接寻址movl (%ebx),%edx &lt;==&gt;edx = (int32_t)ebx（5）变址寻址movl 4(%ebx),%edx &lt;==&gt;edx = (int32_t)(ebx+4)(2) pushl和pop指令，pushl用于入栈（栈的扩张），pop用于出栈（栈的收缩，栈是向下生长的，堆栈基指针ebp指向栈底，栈顶指针esp指向栈顶。入栈操作：pushl %eax完成的操作包括两步，先subl $4,%esp，再movl %eax,(%esp)出栈操作：pop %eax完成的操作包括两步，先movl (%esp)，%eax，再addl $4,%esp（3）CALL主要用于函数调用，如调用0x1234处的函数，即先push %eip，再movl %0x1234,%eip。（4）RET指令用于恢复操作，完成pop %eip操作（5）enter和leave操作enter 为置空栈操作，可以理解为先pushl %ebp，再movl %esp,%ebp，而leave用于撤销函数调用堆栈，即先movl %ebp,%esp，再popl %ebp 注意：（1）函数调用堆栈是由逻辑上多个堆栈叠加起来的（比如函数的嵌套）（2）函数的返回值默认使用eax寄存器存储返回给上一级函数 二、汇编一个简单的c程序分析其汇编指令执行过程先编写一个main.c的小程序，程序代码如下所示：使用gcc –S –o main.s main.c -m32指令将main.c编译成汇编代码保存在main.s中，main.s如下所示：进入main.s汇编文件，去掉所有以.开始的代码行（以.开始的代码是连接时的辅助信息）得到纯汇编代码如下：12345678910111213141516171819202122232425g: pushl %ebp movl %esp, %ebp movl 8(%ebp), %eax addl $2, %eax popl %ebp retf: pushl %ebp movl %esp, %ebp subl $4, %esp movl 8(%ebp), %eax movl %eax, (%esp) call g leave retmain: pushl %ebp movl %esp, %ebp subl $4, %esp movl $4, (%esp) call f addl $6, %eax leave ret 初始时，esp和ebp均指向栈顶，即地址为为0位置，汇编代码的入口也为main函数，从main函数开始分析如下：1.执行完pushl %ebp后，esp-4指向地址1，ebp位置不变；接着执行movl %esp, %ebp，将esp的地址赋给ebp，此时esp和ebp均指向地址1；再执行subl $4, %esp和movl $4, (%esp)，先esp-4，即esp地址向下移动一位，指向2，再将4这个值存放到地址2处2.执行call f,执行call时实际执行两个动作，pushl %eip ; movl f ,%eip,即将eip压栈，eip指向的是23行代码，同时跳转到f执行，注意这里esp会接着向下移动一位，即esp指向地址3，然后跳转到f中执行。3.在f中执行完pushl %ebp后，esp-4指向地址4，ebp位置不变扔指向1将ebp1的内容压入3中，在执行过movl%esp，%ebp后，esp和ebp置于相同的标号处（4）,接着执行subl $4，%esp，esp向下移动到地址5，movl 8(%ebp),%eax 变址寻址，将ebp（此处为标号4）加8（向上移动两个标号，也就是标号2处）的值赋给eax，所以%eax = 4;接着执行movl %eax,(%esp)，将eax的内容也就是4赋值到esp下也就是标号5处 。4.执行call，此时eip指向第15行代码leave的位置,并由eip指向g跳转到g中去执行5.在g中执行pushl %ebp同上，将esp向下移动，将ebp（标号为4）压栈 ，esp为6；和在f中分析方法一样，movl %esp,%ebp ，esp和ebp指向相同的位置6，ebp向上移动两个标号的值（也就是4）赋给eax，%eax中存放的值为4，addl操作，将eax的值与立即数2相加，结果为6，将6存回到eax ，popl %ebp,将ebp的值放回到ebp，执行效果：ebp重新指向标号为4的位置,同时esp减4（向上移动一位指向5）6.ret执行popl %eip，也就是说esp向上移动指向5的标号的位置，同时eip指向15行指令的位置（call的下一条指令）7.回到f中执行，leave相当于执行两条指令，首先，将esp指向ebp相同的位置（也就是标号4的位置），popl %ebp，将ebp出栈，此时ebp指回标号1的位置，由于popl，esp向上移动一位。ret执行popl %eip，由于popl，esp向上移动一位，指向标号2，eip指向第23行代码处8.eip执行第23行代码，回到main中，执行eax此时的值为6，执行addl，6+6 = 12，将12存回到eax。执行leave，分为两步， movl %ebp，%esp，将esp指向ebp的位置，popl %ebp，将ebp出栈（ebp指向0的位置），popl指令时esp向上移动，也就是说esp，ebp均指向标号0的位置，栈回到main函数最初的状态。 ret，return的是main函数之前的堆栈至此，小程序运行完毕。通过下面的图片可以更清晰的观察这一过程： 三、实验总结–对计算机如何工作的理解计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去。直至遇到停止指令。简单来说就是CPU负责处理和运算，存储器负责保存指令和数据。通过操作系统得调度和安排，不停地进行取址、译码、执行的循环。冯诺依曼体系结构的核心就是存储和控制流程，预先要把指挥计算机如何进行操作的指令序列（称为程序）和原始数据通过输入设备输送到计算机内存贮器中。每一条指令中明确规定了计算机从哪个地址取数，进行什么操作，然后送到什么地址去等步骤。计算机之所以能自动，正确的按人们的意图工作，是由于人们事先已把计算机如何工作的程序和原始数据通过输入设备送到计算机的存储器中。当计算机执行时，控制器就把这些指令一条接一条地从存储器中取出来，加以翻译，并按指令的要求进行相应的操作，直到遇到停止指令或发生计算机无法继续运行的情况为止。其实计算机就是个很单纯的机器，我们写好了让它可以读懂的语言，它才能够按照我们的命令去一步步执行！所以，好好学习，天天向上吧！","tags":[{"name":"Linux","slug":"Linux","permalink":"http://tpioneer.github.io/tags/Linux/"}]},{"title":"前端入门笔记一——html5语义化标签","date":"2017-02-22T05:56:31.000Z","path":"2017/02/22/前端入门笔记（一）/","text":"关键词： html5 语义化 前端 前言 首先，这篇文章并不是介绍html的所有标签，这里仅仅是对html5中新定义的一系列语义化标签如&lt;header&gt;,&lt;nav&gt;,&lt;section&gt;等的一个简单 的汇总，这些语义化的标签的出现，不仅提高了开发效率，同时相对于使用过多的div，这些标签的出现极大的增强了页面的语义化。下面总结了一 些常用的语义化标签。 header标签header 标签定义文档的页眉（介绍信息），通常是一些引导和导航信息。整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素。 示例如下：1234&lt;header&gt;&lt;p&gt;this is the page Logo&lt;/p&gt;&lt;nav&gt;this is page navigation&lt;/nav&gt;&lt;/header&gt; footer标签footer 标签定义文档或节的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等123&lt;footer&gt; COPYRIGHT@Tpioneer&lt;/footer&gt; nav标签nav 标签定义显示导航链接不是所有的成组的超级链接都需要放在nav标签里。nav标签里应该放入一些当前页面的主要导航链接。 例如在页脚显示一个站点的导航链接（如首页，服务信息页面，版权信息页面等等），就可以使用nav标签，当然，这不是必须的 示例如下：1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;HTML 5&lt;/li&gt; &lt;li&gt;CSS3&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; article标签article标签装载显示一个独立的文章内容。例如一篇完整的论坛帖子，一则网站新闻，一篇博客文章等等，一个用户评论等等。artilce可以嵌套，则内层的artilce对外层的article标签有隶属的关系，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论。在这里需要注意的是，article标签的内容独立于文档的其余部分。 示例如下：123456&lt;article&gt; &lt;h1&gt;文章标题&lt;/h1&gt; 这是一篇文章 &lt;article&gt;评论1...&lt;/article&gt; &lt;article&gt;评论2...&lt;/article&gt;&lt;/article&gt; aside标签aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 示例如下：1234567&lt;article&gt; &lt;p&gt;内容&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;广告&lt;/h1&gt; &lt;p&gt;今日头条&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt; section标签section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。section使用注意：一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。表示文档中的节或者段；article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div。 示例如下：1234567891011&lt;section&gt; &lt;h1&gt;section&lt;/h1&gt; &lt;article&gt; &lt;h2&gt;section&lt;/h1&gt; &lt;p&gt;section的介绍&lt;/p&gt; &lt;section&gt; &lt;h3&gt;关于其他&lt;/h3&gt; &lt;p&gt;关于其他section的介绍&lt;/p&gt; &lt;/section&gt; &lt;/article&gt;&lt;/section&gt; time标签time是文本标签，用来标记一篇文章的发布时间。示例如下：1&lt;time datetime=\"2017-02-15\" pubdate&gt;2017年02月15日&lt;/time&gt; figure标签figure标签规定独立的流内容（图像、图表、照片、代码等等）。figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。 示例如下：12345&lt;figure&gt; &lt;p&gt;黄浦江上的的卢浦大桥&lt;/p&gt; &lt;p&gt;拍摄者：W3School 项目组，拍摄时间：2010 年 10 月&lt;/p&gt; &lt;img src=\"/i/shanghai_lupu_bridge.jpg\" width=\"350\" height=\"234\" /&gt;&lt;/figure&gt; 总结以上这些标签都是html5中新出现的语义化标签，在定义有语义的内容时，优先选择语义化标签而不是div，例如页眉用header，导航用nav，页脚用footer等等。当然这也不是说div标签就没有意义了，因为div是没有任何意义的元素，它只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。","tags":[{"name":"前端","slug":"前端","permalink":"http://tpioneer.github.io/tags/前端/"}]},{"title":"HEXO搭建你的专属博客","date":"2017-02-21T15:33:56.000Z","path":"2017/02/21/HEXO搭建你的专属博客/","text":"关键词：github hexo blog STEP1 前期准备 在这里默认你已经拥有了github账号，如果没有，还等什么，赶快加入最大的同性交友平台吧（雾。 在github中创建一个名为username.github.io（这里的username即你的账号名，比如我的为Tpioneer.github.io）的库，创建完 后可以试着往库中push一个简单的index.html如下。（github的简单操作可以参考如下教程） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;p&gt;I'm hosted with GitHub Pages.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 接着在你的浏览器中输入https://username.github.io/（username为你的账号名），如果没什么问题的话即可访问到Hello World。 同时，需要安装git，可以去官网下载。 STEP2 hexo环境配置与安装 hexo是一款基于Node.js的静态博客框架, 在安装hexo之前，我们需要先安装node.js,这里对安装不做过多介绍，官网的文档已经很详细了。 Node和Git都安装好后,首先创建一个blog文件夹,然后进入blog目录来安装Hexo（windows用户推荐用Git Bash）。执行如下命令安装Hexo： sudo npm install -g hexo 安装完成后，执行init命令初始化hexo,命令： hexo init然后等待安装完成，即完成了hexo的安装。 安装完成后需要对hexo进行配置，找到/hexo/_config.yml文件，用任意编辑器打开该文件，拉到最后找到Deployment,将其改为下图所示内容： 这里有个需要注意的点，在冒号后面一定要空格，否则识别不出来 修改头像，同样需要打开_config.yml ，找到 avatar: 这一行，然后添加头像的URL就行了，当然你也可以将头像图片放入hexo/source/img目录下，然后将配置改为如下：avatar: /img/xxx.jpg 同理可以修改你的博客名，博客描述，作者等信息，这里发一张我的参考配置如下： 当然配置文件中还有很多其他的配置选项，在这里就不一一赘述了，官网上提供了更详细的参考资料 STEP3 hexo的部署和常用命令 部署步骤如下(建议在每次重新部署时都执行一次hexo clean)： hexo clean hexo generate (hexo g) hexo deploy (hexo d)在部署完成后，在你的浏览器中输入https://username.github.io/，大功告成，撒花★,°:.☆(￣▽￣)/$:.°★ 。 当然，这只是简单的部署了属于你自己的一个blog，你还需要稍微再花费点时间让你的blog更加丰富多彩。 首先，你需要了解下面提供的一些常用命令： hexo new “postName” #新建文章 hexo new page”pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 了解了这些命令，相信你写一些简单的blog已经没有什么问题了，但是中庸的官方主题肯定不会让你特别喜欢。这里有个主题集合,你可以在这里尽情挑选你喜欢的主题，每个主题的github中都有相应的文档，所以，大胆的去尝试吧，相信你一定能找到适合你的那个。 最后，送上一份Markdown的语法说明书,还等什么，赶快开启你的私人blog之旅吧!","tags":[{"name":"学习","slug":"学习","permalink":"http://tpioneer.github.io/tags/学习/"}]}]